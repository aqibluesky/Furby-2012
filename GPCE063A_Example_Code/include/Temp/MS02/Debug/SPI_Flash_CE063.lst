Generalplus u'nSP Assembler - Ver. 1.14.13.0

                            	//==========================================================================
                            	// File Name   : SACM_DVR4800_USER.asm
                            	// Description : Users implement functions
                            	// Written by  : Ray Cheng
                            	// Last modified date:
                            	//              2005/12/26
                            	// Note: 
                            	//==========================================================================
                            	//**************************************************************************
                            	// Header File Included Area
                            	//**************************************************************************
                            	.include GPCE063.inc;
                     <      	//==========================================================================
                     <      	// File Name   : GPCE063.inc
                     <      	// Description : GPCE063 registers and constants definition
                     <      	// Written by  : Chimc
                     <      	// Last modified date:
                     <      	//              2008/03/19
                     <      	//==========================================================================
                     <      	.ifndef __GPCE063_INC__
                     <      	.define __GPCE063_INC__
                     <      	
                     <      	//--------------------------------------------------------------------------------------------------------------------------------------------
                     <      	//	GPIO Configration
                     <      	//	Dir		Att		Dat		Function Description			Wakeup
                     <      	//	0		0		0		Input Pull Low					Yes
                     <      	//	0		0		1		Input Pull High					Yes
                     <      	//	0		1		0		Input Floating					Yes
                     <      	//	0		1		1		Input Floating					Yes
                     <      	//	1		0		0		Output High (Inverted)			Yes		(With Io Toggle Capability)
                     <      	//	1		0		1		Output Low (Inverted)			Yes		(With Io Toggle Capability)
                     <      	//	1		1		0		Output Low						Yes
                     <      	//	1		1		1		Output High						Yes
                     <      	//--------------------------------------------------------------------------------------------------------------------------------------------
                     <      	
                     <      	//--------------------------------------------------------------------------------------------------------------------------------------------
                     <      	//	Special IO Function
                     <      	//	IOA_Func	Bit15	Bit14	Bit13	Bit12	Bit11	Bit10	Bit9	Bit8	Bit7	Bit6	Bit5	Bit4	Bit3	Bit2	Bit1	Bit0
                     <      	//	IR			-		-		-		-		-		-		-		-		-		-		-		-		-		-		IROUT	-
                     <      	//	Wakeup		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes		Yes
                     <      	//	FB/OSC		-		-		-		-		FO2		FI2		FO1		FI1		-		-		-		-		-		-		-		-
                     <      	//	Ext_Int		-		-		-		-		-		EXT2	-		EXT1	-		-		-		-		-		-		-		-
                     <      	//	IOPWM		-		-		-		-		-		-		-		-		-		-		-		-		-		-		-		IOPWM
                     <      	//	SPI			SPIRX	SPITX	SPICK	SPICS	-		-		-		-		-		-		-		-		-		-		-		-
                     <      	//	HighDriving	-		-		-		-		-		-		-		-		Yes		Yes		Yes		Yes		-		-		-		-
                     <      	//--------------------------------------------------------------------------------------------------------------------------------------------
                     <      	//	IOB_Func	Bit15	Bit14	Bit13	Bit12	Bit11	Bit10	Bit9	Bit8	Bit7	Bit6	Bit5	Bit4	Bit3	Bit2	Bit1	Bit0
                     <      	//	ADC_CH		-		-		-		-		-		-		-		-		AN7		AN6		AN5		AN4		AN3		AN2		AN1		AN0
                     <      	//--------------------------------------------------------------------------------------------------------------------------------------------
                     <      	
                     <      	//////////////////////////////////////////////////////////////////////////////////////
                     <      	//====================================================================================
                     <      	//	Port Definition
                     <      	//====================================================================================
                     <      	//////////////////////////////////////////////////////////////////////////////////////
                     <      	.define	P_IOA_Data				0x2000
                     <      	.define P_IOA_Buffer			0x2001
                     <      	.define	P_IOA_Dir				0x2002
                     <      	.define	P_IOA_Attrib			0x2003
                     <      	.define	P_IOB_Data				0x2004
                     <      	.define P_IOB_Buffer			0x2005
                     <      	.define	P_IOB_Dir				0x2006
                     <      	.define	P_IOB_Attrib			0x2007
                     <      	.define P_IO_Ctrl				0x2008
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_TimerA_Data			0x2010
                     <      	.define P_TimerA_CNTR			0x2011
                     <      	.define P_TimerB_Data			0x2012
                     <      	.define P_TimerB_CNTR			0x2013
                     <      	.define P_TimerC_Data			0x2014
                     <      	.define P_TimerC_CNTR			0x2015
                     <      	.define P_Timer_Ctrl			0x2016
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_PWM_Ctrl				0x2020
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_System_Clock			0x2030
                     <      	.define P_System_Reset			0x2031
                     <      	.define P_Reset_LVD_Ctrl		0x2032
                     <      	.define P_TimeBase_Clear		0x2033
                     <      	.define P_Watchdog_Clear		0x2034
                     <      	.define P_Wait_Ctrl				0x2035
                     <      	.define P_System_Sleep			0x2036
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_DAC_Ctrl				0x2040
                     <      	.define P_DAC_Data				0x2041
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_INT_Ctrl				0x2050
                     <      	.define P_INT_Status			0x2051
                     <      	.define P_FIQ_Sel				0x2052
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_SPI_Ctrl				0x2060
                     <      	.define P_SPI_TX_Status			0x2061
                     <      	.define P_SPI_TX_Data			0x2062
                     <      	.define P_SPI_RX_Status			0x2063
                     <      	.define P_SPI_RX_Data			0x2064
                     <      	.define P_SPI_Misc				0x2065
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define P_ADC_Ctrl				0x2070
                     <      	.define P_ADC_Data				0x2071
                     <      	.define P_ADC_LineIn_BitCtrl	0x2072
                     <      	
                     <      	//---------------------------------------------------
                     <      	.define	P_Flash_Ctrl			0x26FF
                     <      	
                     <      	//---------------------------------------------------
                     <      	//---------------------------------------------------
                     <      	//---------------------------------------------------
                     <      	
                     <      	
                     <      	//////////////////////////////////////////////////////////////////////////////////////
                     <      	//====================================================================================
                     <      	// Constant Definition
                     <      	//====================================================================================
                     <      	//////////////////////////////////////////////////////////////////////////////////////
                     <      	
                     <      	//====================================================================================
                     <      	// P_IO_Ctrl (0x2008)
                     <      	//====================================================================================
                     <      	// Bit11 : IO_Toggle_En
                     <      	.define	C_IO_Toggle_Disable		0x0000		// IO Toggle Disable 
                     <      	.define	C_IO_Toggle_Enable		0x0800		// IO Toggle Enable 
                     <      	// Bit10 : FW_SPI_CS
                     <      	.define C_FW_SPI_CS				0x0400
                     <      	.define	C_SPI_CS_Firmware		0x0000		// CS Control by Firmware
                     <      	.define	C_SPI_CS_Hardware		0x0400		// CS Control by Hardware
                     <      	// Bit[9:8] : IR_Duty === IRout:IOA1
                     <      	.define	C_IR_Duty				0x0300
                     <      	.define	C_IR_Duty_DIV_2			0x0000		// 1/2 Duty
                     <      	.define	C_IR_Duty_DIV_3			0x0100		// 1/3 Duty
                     <      	.define	C_IR_Duty_DIV_4			0x0200		// 1/4 Duty
                     <      	.define	C_IR_Duty_DIV_5			0x0300		// 1/5 Duty
                     <      	// Bit[7:6] : IR_Ctrl
                     <      	.define	C_IR_Ctrl				0x00C0
                     <      	.define	C_IR_Disable			0x0000		// IR Disable ; IOA1 as Normal IO
                     <      	.define	C_IR_With_TimerA		0x0040		// IR Function Enable with Timer A as Source
                     <      	.define	C_IR_With_TimerB		0x0080		// IR Function Enable with Timer B as Source
                     <      	.define	C_IR_With_TimerC		0x00C0		// IR Function Enable with Timer C as Source
                     <      	// Bit[5:4] : EXT2_Ctrl === FI2:IOA10  FO2:IOA11
                     <      	.define	C_EXT2_Ctrl				0x0030
                     <      	.define	C_EXT2_Normal_Rising	0x0000		// Normal IO With Rising Edge Trigger
                     <      	.define	C_EXT2_Normal_Falling	0x0010		// Normal IO With Falling Edge Trigger
                     <      	.define	C_EXT2_Feedback_Rising	0x0020		// Feedback Oscillator With Rising Edge Trigger
                     <      	.define	C_EXT2_Feedback_Falling	0x0030		// Feedback Oscillator With Falling Edge Trigger
                     <      	// Bit[3:2] : EXT1_Ctrl === FI1:IOA8  FO1:IOA9
                     <      	.define	C_EXT1_Ctrl				0x000C
                     <      	.define	C_EXT1_Normal_Rising	0x0000		// Normal IO With Rising Edge Trigger
                     <      	.define	C_EXT1_Normal_Falling	0x0004		// Normal IO With Falling Edge Trigger
                     <      	.define	C_EXT1_Feedback_Rising	0x0008		// Feedback Oscillator With Rising Edge Trigger
                     <      	.define	C_EXT1_Feedback_Falling	0x000C		// Feedback Oscillator With Falling Edge Trigger
                     <      	// Bit[1:0] : IO_Toggle_Ctrl 
                     <      	.define	C_IO_Toggle_Ctrl		0x0003
                     <      	.define C_IO_Toggle_With_FRTC	0x0000		// IO Toggle Function Source form FRTC directly
                     <      	.define C_IO_Toggle_With_TimerA	0x0001		// IO Toggle Function with Timer A
                     <      	.define C_IO_Toggle_With_TimerB	0x0002		// IO Toggle Function with Timer B
                     <      	.define C_IO_Toggle_With_TimerC	0x0003		// IO Toggle Function with Timer C
                     <      	
                     <      	//====================================================================================
                     <      	// P_Timer_Ctrl (0x2016)  Timer Setting
                     <      	//====================================================================================
                     <      	// Bit[3:0] : TMASEL
                     <      	.define C_TimerA_Sel			0x000F
                     <      	.define C_TimerA_Disable		0x0000
                     <      	.define C_TimerA_Software_Count	0x0001
                     <      	.define C_TimerA_FRTC_EXT2		0x0002
                     <      	.define C_TimerA_EXT1_EXT2		0x0002
                     <      	.define C_TimerA_FPLL_EXT2		0x0003
                     <      	.define C_TimerA_EXT2_64Hz		0x0004
                     <      	.define C_TimerA_EXT2_16Hz		0x0005
                     <      	.define C_TimerA_EXT2_2Hz		0x0006
                     <      	.define C_TimerA_EXT2			0x0007
                     <      	.define C_TimerA_FRTC_64Hz		0x0008
                     <      	//.define C_TimerA_EXT1_64Hz	0x0008
                     <      	.define C_TimerA_FRTC_16Hz		0x0009
                     <      	//.define C_TimerA_EXT1_16Hz	0x0009
                     <      	.define C_TimerA_FRTC_2Hz		0x000A
                     <      	//.define C_TimerA_EXT1_2Hz		0x000A
                     <      	.define C_TimerA_FRTC			0x000B
                     <      	//.define C_TimerA_EXT1			0x000B
                     <      	.define C_TimerA_FPLL_64Hz		0x000C
                     <      	.define C_TimerA_FPLL_16Hz		0x000D
                     <      	.define C_TimerA_FPLL_2Hz		0x000E
                     <      	.define C_TimerA_FPLL			0x000F
                     <      	// Bit[7:4] : TMBSEL
                     <      	.define C_TimerB_Sel			0x00F0
                     <      	.define C_TimerB_Disable		0x0000
                     <      	.define C_TimerB_Software_Count	0x0010
                     <      	.define C_TimerB_FRTC_EXT2		0x0020
                     <      	.define C_TimerB_EXT1_EXT2		0x0020
                     <      	.define C_TimerB_FPLL_EXT2		0x0030
                     <      	.define C_TimerB_EXT2_64Hz		0x0040
                     <      	.define C_TimerB_EXT2_16Hz		0x0050
                     <      	.define C_TimerB_EXT2_2Hz		0x0060
                     <      	.define C_TimerB_EXT2			0x0070
                     <      	.define C_TimerB_FRTC_64Hz		0x0080
                     <      	//.define C_TimerB_EXT1_64Hz	0x0080
                     <      	.define C_TimerB_FRTC_16Hz		0x0090
                     <      	//.define C_TimerB_EXT1_16Hz	0x0090
                     <      	.define C_TimerB_FRTC_2Hz		0x00A0
                     <      	//.define C_TimerB_EXT1_2Hz		0x00A0
                     <      	.define C_TimerB_FRTC			0x00B0
                     <      	//.define C_TimerB_EXT1			0x00B0
                     <      	.define C_TimerB_FPLL_64Hz		0x00C0
                     <      	.define C_TimerB_FPLL_16Hz		0x00D0
                     <      	.define C_TimerB_FPLL_2Hz		0x00E0
                     <      	.define C_TimerB_FPLL			0x00F0
                     <      	// Bit[11:8] : TMCSEL
                     <      	.define C_TimerC_Sel			0x0F00
                     <      	.define C_TimerC_Disable		0x0000
                     <      	.define C_TimerC_Software_Count	0x0100
                     <      	.define C_TimerC_FRTC_EXT2		0x0200
                     <      	.define C_TimerC_EXT1_EXT2		0x0200
                     <      	.define C_TimerC_FPLL_EXT2		0x0300
                     <      	.define C_TimerC_EXT2_64Hz		0x0400
                     <      	.define C_TimerC_EXT2_16Hz		0x0500
                     <      	.define C_TimerC_EXT2_2Hz		0x0600
                     <      	.define C_TimerC_EXT2			0x0700
                     <      	.define C_TimerC_FRTC_64Hz		0x0800
                     <      	//.define C_TimerC_EXT1_64Hz	0x0800
                     <      	.define C_TimerC_FRTC_16Hz		0x0900
                     <      	//.define C_TimerC_EXT1_16Hz	0x0900
                     <      	.define C_TimerC_FRTC_2Hz		0x0A00
                     <      	//.define C_TimerC_EXT1_2Hz		0x0A00
                     <      	.define C_TimerC_FRTC			0x0B00
                     <      	//.define C_TimerC_EXT1			0x0B00
                     <      	.define C_TimerC_FPLL_64Hz		0x0C00
                     <      	.define C_TimerC_FPLL_16Hz		0x0D00
                     <      	.define C_TimerC_FPLL_2Hz		0x0E00
                     <      	.define C_TimerC_FPLL			0x0F00
                     <      	// Bit12 : Timer A input source select; 0 for FRTC, 1 for EXT1
                     <      	//.define C_TimerA_Input1			0x1000
                     <      	//.define C_TimerA_Input1_FRTC	0x0000
                     <      	//.define C_TimerA_Input1_EXT1	0x1000
                     <      	// Bit13 : Timer B input source select; 0 for FRTC, 1 for EXT1
                     <      	//.define C_TimerB_Input1			0x2000
                     <      	//.define C_TimerB_Input1_FRTC	0x0000
                     <      	//.define C_TimerB_Input1_EXT1	0x2000
                     <      	// Bit14 : Timer C input source select; 0 for FRTC, 1 for EXT1
                     <      	//.define C_TimerC_Input1			0x4000
                     <      	//.define C_TimerC_Input1_FRTC	0x0000
                     <      	//.define C_TimerC_Input1_EXT1	0x4000
                     <      	// Bit15 : Reserved
                     <      	
                     <      	//.define SystemClock				20480000
                     <      	//.define SystemClock				24576000
                     <      	//.define SystemClock				32768000
                     <      	//.define SystemClock				40960000
                     <      	.define SystemClock				49152000
                     <      	//.define SystemClock				12000000		// For FPGA Test
                     <      	//.define SystemClock				24000000		// For FPGA Test
                     <      	//.define SystemClock				48000000		// For FPGA Test
                     <      	
                     <      	.define C_Timer_Setting_1K   	65536 - (SystemClock / 1000)
                     <      	.define C_Timer_Setting_2K     	65536 - (SystemClock / 2000)
                     <      	.define C_Timer_Setting_3K     	65536 - (SystemClock / 3000)
                     <      	.define C_Timer_Setting_4K     	65536 - (SystemClock / 4000)
                     <      	.define C_Timer_Setting_5K     	65536 - (SystemClock / 5000)
                     <      	.define C_Timer_Setting_6K     	65536 - (SystemClock / 6000)
                     <      	.define C_Timer_Setting_7K     	65536 - (SystemClock / 7000)
                     <      	.define C_Timer_Setting_8K    	65536 - (SystemClock / 8000)
                     <      	.define C_Timer_Setting_9K     	65536 - (SystemClock / 9000)
                     <      	.define C_Timer_Setting_10K    	65536 - (SystemClock / 10000)
                     <      	.define C_Timer_Setting_11K    	65536 - (SystemClock / 11000)
                     <      	.define C_Timer_Setting_12K    	65536 - (SystemClock / 12000)
                     <      	.define C_Timer_Setting_13K    	65536 - (SystemClock / 13000)
                     <      	.define C_Timer_Setting_14K    	65536 - (SystemClock / 14000)
                     <      	.define C_Timer_Setting_15K    	65536 - (SystemClock / 15000)
                     <      	.define C_Timer_Setting_16K    	65536 - (SystemClock / 16000)
                     <      	.define C_Timer_Setting_20K    	65536 - (SystemClock / 20000)
                     <      	.define C_Timer_Setting_24K    	65536 - (SystemClock / 24000)
                     <      	.define C_Timer_Setting_28K   	65536 - (SystemClock / 28000)
                     <      	.define C_Timer_Setting_32K    	65536 - (SystemClock / 32000)
                     <      	.define C_Timer_Setting_36K   	65536 - (SystemClock / 36000)
                     <      	.define C_Timer_Setting_40K   	65536 - (SystemClock / 40000)
                     <      	.define C_Timer_Setting_48K    	65536 - (SystemClock / 48000)
                     <      	.define C_Timer_Setting_64K    	65536 - (SystemClock / 64000)
                     <      	.define C_Timer_Setting_500K   	65536 - (SystemClock / 500000)
                     <      	.define C_Timer_Setting_15555  	65536 - (SystemClock / 15555)	// For FPGA Test
                     <      	.define C_Timer_Setting_17777  	65536 - (SystemClock / 17777)	// For FPGA Test
                     <      	
                     <      	
                     <      	//====================================================================================
                     <      	// P_PWM_Ctrl (0x2020)  IOPWM
                     <      	//====================================================================================
                     <      	// Bit[15] : IOPWM_CNT_Clear
                     <      	.define	C_IOPWM_CNT_Clear		0x8000
                     <      	// Bit[14:7] : Reserved
                     <      	// Bit[6] : IOPWM_Mask
                     <      	.define	C_IOPWM_Mask			0x0040
                     <      	.define	C_IOPWM_Mask_Disable	0x0000		//default
                     <      	.define	C_IOPWM_Mask_Enable		0x0040
                     <      	// Bit[5:4] : Clock Source for IOPWM
                     <      	.define	C_IOPWM_CLK_SRC			0x0030
                     <      	.define	C_IOPWM_SRC_FRTC_Div2	0x0000
                     <      	.define	C_IOPWM_SRC_TimerA		0x0010
                     <      	.define	C_IOPWM_SRC_TimerB		0x0020
                     <      	.define	C_IOPWM_SRC_TimerC		0x0030
                     <      	// Bit[3:0] : PWM_Duty
                     <      	.define	C_IOPWM_Duty			0x000F
                     <      	.define C_IOPWM_OFF				0x0000
                     <      	.define C_IOPWM_1_Div_16		0x0001
                     <      	.define C_IOPWM_2_Div_16		0x0002
                     <      	.define C_IOPWM_3_Div_16		0x0003
                     <      	.define C_IOPWM_4_Div_16		0x0004
                     <      	.define C_IOPWM_5_Div_16		0x0005
                     <      	.define C_IOPWM_6_Div_16		0x0006
                     <      	.define C_IOPWM_7_Div_16		0x0007
                     <      	.define C_IOPWM_8_Div_16		0x0008
                     <      	.define C_IOPWM_9_Div_16		0x0009
                     <      	.define C_IOPWM_10_Div_16		0x000A
                     <      	.define C_IOPWM_11_Div_16		0x000B
                     <      	.define C_IOPWM_12_Div_16		0x000C
                     <      	.define C_IOPWM_13_Div_16		0x000D
                     <      	.define C_IOPWM_14_Div_16		0x000E
                     <      	.define C_IOPWM_1_Div_2			0x000F
                     <      	
                     <      	//====================================================================================
                     <      	// P_System_Clock (0x2030)  
                     <      	// The System Clock can be configured form 24.576MHz to 49.152MHz
                     <      	//====================================================================================
                     <      	// Bit[7:5] : FOSC
                     <      	.define C_FOSC					0x00E0
                     <      	.define C_FOSC_24576KHz			0x0000
                     <      	.define C_FOSC_20480KHz			0x0020
                     <      	.define C_FOSC_32768KHz			0x0040
                     <      	.define C_FOSC_40960KHz			0x0060
                     <      	.define C_FOSC_49152KHz			0x0080
                     <      	.define C_FOSC_49152KHz_M1		0x00A0
                     <      	.define C_FOSC_49152KHz_M2		0x00C0
                     <      	.define C_FOSC_49152KHz_M3		0x00E0
                     <      	// Bit[4] : 32KHz Sleep Status
                     <      	.define	C_Sleep_RTC_Status		0x0010
                     <      	.define	C_Sleep_RTC_SLP_Off		0x0000
                     <      	.define	C_Sleep_RTC_SLP_Work	0x0010
                     <      	// Bit[3] : Strong Mode
                     <      	.define C_RTC_Mode_Sel			0x0008
                     <      	.define C_RTC_Mode_Weak			0x0000
                     <      	.define C_RTC_Mode_Strong		0x0008
                     <      	// Bit[2:0] : CPU Clock
                     <      	.define	C_CPU_CLK				0x0007
                     <      	.define	C_CPU_CLK_FOSC			0x0000
                     <      	.define	C_CPU_CLK_FOSC_DIV_2	0x0001
                     <      	.define	C_CPU_CLK_FOSC_DIV_4	0x0002
                     <      	.define	C_CPU_CLK_FOSC_DIV_8	0x0003			// Default Value
                     <      	.define	C_CPU_CLK_FOSC_DIV_16	0x0004
                     <      	.define	C_CPU_CLK_FOSC_DIV_32	0x0005
                     <      	.define	C_CPU_CLK_FOSC_DIV_64	0x0006
                     <      	.define	C_CPU_CLK_FOSC_DIV_128	0x0007
                     <      	
                     <      	// P_System_Sleep (0x2036)
                     <      	.define C_System_Sleep			0x5555
                     <      	// P_System_Reset (0x2031)
                     <      	.define C_Software_Reset		0x5555
                     <      	// P_TimeBase_Clear (0x2033)
                     <      	.define	C_TimeBase_Clear		0x5555			// Write any value to clear
                     <      	// P_Watchdog_Clear (0x2034)
                     <      	.define	C_Watchdog_Clear		0x5555
                     <      	
                     <      	//====================================================================================
                     <      	// P_Reset_LVD_Ctrl (0x2032)
                     <      	//====================================================================================
                     <      	// Bit[15]
                     <      	.define C_Watchdog_Reset_Flag	0x8000			// Flag
                     <      	// Bit[14]
                     <      	.define C_Software_Reset_Flag	0x4000			// Flag
                     <      	// Bit[13]
                     <      	.define C_Wathcdog_Reset_Err_Flag	0x2000			// Flag
                     <      	// Bit[12]
                     <      	.define C_ILL_Addr_Reset_Flag	0x1000			// Flag
                     <      	// Bit[11]
                     <      	.define C_LVD_Status_Flag		0x0800			// Flag
                     <      	// Bit[9:2] Reserved
                     <      	// Bit[1:0] : LVD_Ctrl
                     <      	.define	C_LVD_Ctrl				0x0003
                     <      	.define	C_LVD_Ctrl_3D2V			0x0000			// Default Value
                     <      	.define	C_LVD_Ctrl_3D0V			0x0001
                     <      	.define	C_LVD_Ctrl_2D8V			0x0002
                     <      	.define	C_LVD_Ctrl_2D6V			0x0003
                     <      	// LVR always setting 2.2v
                     <      	
                     <      	//====================================================================================
                     <      	// P_Wait_Ctrl (0x2035)
                     <      	//====================================================================================
                     <      	.define	C_Wait_State_Reg		0x000F
                     <      	.define C_Wait_State_2Cycles1	0x0000
                     <      	.define C_Wait_State_2Cycles2	0x0001
                     <      	.define C_Wait_State_2Cycles	0x0002
                     <      	.define C_Wait_State_3Cycles	0x0003			// Default Value
                     <      	.define C_Wait_State_4Cycles	0x0004
                     <      	.define C_Wait_State_5Cycles	0x0005
                     <      	.define C_Wait_State_6Cycles	0x0006
                     <      	.define C_Wait_State_7Cycles	0x0007
                     <      	.define C_Wait_State_8Cycles	0x0008
                     <      	.define C_Wait_State_9Cycles	0x0009
                     <      	.define C_Wait_State_10Cycles	0x000A
                     <      	.define C_Wait_State_11Cycles	0x000B
                     <      	.define C_Wait_State_12Cycles	0x000C
                     <      	.define C_Wait_State_13Cycles	0x000D
                     <      	.define C_Wait_State_14Cycles	0x000E
                     <      	.define C_Wait_State_15Cycles	0x000F
                     <      	
                     <      	//====================================================================================
                     <      	// P_DAC_Ctrl (0x2040)
                     <      	//====================================================================================
                     <      	// Bit[15:3] : Reserved
                     <      	// Bit[2] : DAC Enable
                     <      	.define	C_DAC_Disable			0x0000
                     <      	.define	C_DAC_Enable			0x0004
                     <      	// Bit[1:0] : DAC Timer Select
                     <      	.define C_DAC_TMR_Sel			0x0003
                     <      	.define C_DAC_TMR_Sel_Manual	0x0000
                     <      	.define C_DAC_TMR_Sel_TimerA	0x0001
                     <      	.define C_DAC_TMR_Sel_TimerB	0x0002
                     <      	.define C_DAC_TMR_Sel_TimerC	0x0003
                     <      	
                     <      	//====================================================================================
                     <      	// P_INT_Ctrl (0x2050)
                     <      	// P_INT_Status (0x2051)
                     <      	// P_FIQ_Sel (0x2052)
                     <      	//====================================================================================
                     <      	// Bit[15:13] : Reserve
                     <      	.define C_IRQ0_TMA					0x1000
                     <      	.define C_IRQ1_TMB					0x0800
                     <      	.define C_IRQ2_TMC					0x0400
                     <      	.define C_IRQ3_SPI					0x0200
                     <      	.define C_IRQ4_KEY					0x0100
                     <      	.define C_IRQ5_EXT1					0x0080
                     <      	.define C_IRQ5_EXT2					0x0040
                     <      	.define C_IRQ6_4096Hz				0x0020
                     <      	.define C_IRQ6_2048Hz				0x0010
                     <      	.define C_IRQ6_512Hz				0x0008
                     <      	.define C_IRQ7_64Hz					0x0004
                     <      	.define C_IRQ7_16Hz					0x0002
                     <      	.define C_IRQ7_2Hz					0x0001
                     <      	
                     <      	//====================================================================================
                     <      	// P_SPI_Ctrl (0x2060)
                     <      	//====================================================================================
                     <      	// Bit[2:0] : Master Mode clock selection : 111b is reserved
                     <      	.define C_SPI_SCK_SEL				0x0007
                     <      	.define C_SCKSEL_FPLL_Div_2			0x0000
                     <      	.define C_SCKSEL_FPLL_Div_4			0x0001
                     <      	.define C_SCKSEL_FPLL_Div_8			0x0002
                     <      	.define C_SCKSEL_FPLL_Div_16		0x0003
                     <      	.define C_SCKSEL_FPLL_Div_32		0x0004
                     <      	.define C_SCKSEL_FPLL_Div_64		0x0005	
                     <      	.define C_SCKSEL_FPLL_Div_128		0x0006
                     <      	// Bit3 : Reserved
                     <      	// Bit4 : SPI Clock Polarity
                     <      	.define	C_SPI_Clock_Pol				0x0010
                     <      	.define C_SPI_Clock_Pol_Normal		0x0000	// Clock Normal or Inverted 
                     <      	.define C_SPI_Clock_Pol_Inverse		0x0010
                     <      	// Bit5 : SPI Clock Phase
                     <      	.define C_SPI_Clock_Phase			0x0020
                     <      	.define C_SPI_Clock_Phase_Normal	0x0000	// Rising Edge Trigger or Falling Edge Trigger depend on Polarity
                     <      	.define C_SPI_Clock_Phase_Shift		0x0020  // (POL=0, PHA=1)
                     <      	// Bit[7:6] : Reserved
                     <      	// Bit8 : SPI Mode
                     <      	.define	C_SPI_Mode					0x0100
                     <      	.define C_MasterMode				0x0000
                     <      	.define C_SlaveMode  				0x0100
                     <      	// Bit[10:9] : Reserved
                     <      	// Bit11 : SPI Reset
                     <      	.define C_SPI_Reset					0x0800
                     <      	// Bit12 : Reserved
                     <      	// Bit13 : Loop Back Mode Selection
                     <      	.define	C_SPI_LBM_Normal			0x0000
                     <      	.define	C_SPI_LBM_Enable			0x2000
                     <      	// Bit14: Reserved
                     <      	// Bit15 : SPI Enable
                     <      	.define C_SPI_Disable				0x0000
                     <      	.define C_SPI_Enable				0x8000
                     <      	
                     <      	//====================================================================================
                     <      	// P_SPI_TX_Status (0x2061)
                     <      	//====================================================================================
                     <      	// Bit[3:0] : SPI TX Flag (read only) : Only 8 FIFOs  
                     <      	.define	C_SPI_TX_Flag				0x0007		// 0 ~ 7
                     <      	// Bit[7:4] : SPI TX level setting
                     <      	.define C_SPI_TX_FIFO_Level			0x0070		// 0 ~ 7
                     <      	.define C_SPI_TX_FIFO_Level_0		0x0000
                     <      	.define C_SPI_TX_FIFO_Level_1		0x0010
                     <      	.define C_SPI_TX_FIFO_Level_2		0x0020
                     <      	.define C_SPI_TX_FIFO_Level_3		0x0030
                     <      	.define C_SPI_TX_FIFO_Level_4		0x0040
                     <      	.define C_SPI_TX_FIFO_Level_5		0x0050
                     <      	.define C_SPI_TX_FIFO_Level_6		0x0060
                     <      	.define C_SPI_TX_FIFO_Level_7		0x0070
                     <      	// Bit[13:8] : Reserved
                     <      	// Bit14 : SPI TX interrupt enable
                     <      	.define C_SPI_TX_INT_DIS			0x0000
                     <      	.define C_SPI_TX_INT_EN				0x4000
                     <      	// Bit15 : SPI TX interrupt flag
                     <      	.define C_SPI_TX_INT_Flag			0x8000
                     <      	
                     <      	//====================================================================================
                     <      	// P_SPI_RX_Status (0x2063)
                     <      	//====================================================================================
                     <      	// Bit[3:0] : SPI RX Flag (read only)
                     <      	.define	C_SPI_RX_Flag				0x0007		// 0 ~ 7
                     <      	// Bit[7:4] : SPI RX full level setting
                     <      	.define C_SPI_RX_FIFO_Level			0x0070
                     <      	.define C_SPI_RX_FIFO_Level_1		0x0000
                     <      	.define C_SPI_RX_FIFO_Level_2		0x0010
                     <      	.define C_SPI_RX_FIFO_Level_3		0x0020
                     <      	.define C_SPI_RX_FIFO_Level_4		0x0030
                     <      	.define C_SPI_RX_FIFO_Level_5		0x0040
                     <      	.define C_SPI_RX_FIFO_Level_6		0x0050
                     <      	.define C_SPI_RX_FIFO_Level_7		0x0060
                     <      	.define C_SPI_RX_FIFO_Level_8		0x0070
                     <      	// Bit8 : SPI RX buffer overwrite (read only)
                     <      	.define C_SPI_RX_BUF_OVER_ERROR		0x0100
                     <      	// Bit9 : SPI RX buffer full (read only)
                     <      	.define C_SPI_RX_BUF_Full			0x0200
                     <      	// Bit[13:10] : Reserved
                     <      	// Bit14 : SPI Rx interrupt enable
                     <      	.define C_SPI_RX_INT_DIS			0x0000
                     <      	.define C_SPI_RX_INT_EN				0x4000
                     <      	// Bit15 : SPI RX interrupt flag
                     <      	.define C_SPI_RX_INT_Flag			0x8000
                     <      	
                     <      	//====================================================================================
                     <      	// P_SPI_Misc (0x2065)
                     <      	//====================================================================================
                     <      	// Bit0 : Transmit FIFO Empty Flag
                     <      	.define	C_SPI_TX_Empty_Flag				0x0001
                     <      	// Bit1 : Transmit FIFO Not Full Flag
                     <      	.define	C_SPI_TX_NonFull_Flag			0x0002
                     <      	// Bit2 : Receive FIFO Empty Flag
                     <      	.define	C_SPI_RX_Empty_Flag				0x0004
                     <      	// Bit3 : Receive FIFO Full Flag
                     <      	.define	C_SPI_RX_Full_Flag				0x0008
                     <      	// Bit4 : SPI Controller Busy Flag
                     <      	.define	C_SPI_Busy_Flag					0x0010
                     <      	// Bit[7:5] : Reserved
                     <      	// Bit8 : SPI FIFO Smart Mode Register
                     <      	.define	C_SPI_FIFO_Normal_Mode			0x0000
                     <      	.define	C_SPI_FIFO_Smart_Mode			0x0100
                     <      	// Bit9 : SPI FIFO Over Write Mode
                     <      	.define	C_SPI_FIFO_Full_Write_Skipped	0x0000
                     <      	.define	C_SPI_FIFO_Full_Overwrite		0x0200
                     <      	// Bit[15:10] : Reserved
                     <      	
                     <      	//====================================================================================
                     <      	// P_ADC_Ctrl (0x2070)
                     <      	//====================================================================================
                     <      	// Bit[1:0] : Conversion Cycle Select
                     <      	.define	C_ADC_Conv_Cycle				0x0003
                     <      	.define	C_ADC_Conv_Cyc_8				0x0000	// Default
                     <      	.define	C_ADC_Conv_Cyc_16				0x0001
                     <      	.define	C_ADC_Conv_Cyc_32				0x0002
                     <      	.define	C_ADC_Conv_Cyc_64				0x0003
                     <      	// Bit2 : ADC Enable 
                     <      	.define	C_ADC_Disable					0x0000
                     <      	.define	C_ADC_Enable					0x0004
                     <      	// Bit3 : AGC Enable 
                     <      	.define	C_AGC_Disable					0x0000
                     <      	.define	C_AGC_Enable					0x0008
                     <      	// Bit4 : A/D Input Select in Manual Mode
                     <      	.define C_ADC_Ch0_in_MIC 				0x0000
                     <      	.define C_ADC_Ch0_in_LineinPB0			0x0010
                     <      	// Bit5 : V_MIC Power Supply Enable
                     <      	.define	C_ADC_MIC_Disable				0x0000
                     <      	.define	C_ADC_MIC_Enable				0x0020
                     <      	// Bit6 : ADC Chip Enable for Bias Circuit
                     <      	.define	C_ADC_Bias_Disable				0x0000
                     <      	.define	C_ADC_Bias_Enable				0x0040
                     <      	// Bit[8:7] : ADC clock setting
                     <      	.define C_ADC_CLK_Sel					0x0180
                     <      	.define C_ADC_CLK_FPLL_Div_16			0x0000
                     <      	.define C_ADC_CLK_FPLL_Div_32			0x0080
                     <      	.define C_ADC_CLK_FPLL_Div_64			0x0100
                     <      	.define C_ADC_CLK_FPLL_Div_128			0x0180
                     <      	// Bit[11:9] : ADC manual mode channel setting
                     <      	.define C_ADC_Manual_AN0				0x0000
                     <      	.define C_ADC_Manual_AN1				0x0200
                     <      	.define C_ADC_Manual_AN2				0x0400
                     <      	.define C_ADC_Manual_AN3				0x0600
                     <      	.define C_ADC_Manual_AN4				0x0800
                     <      	.define C_ADC_Manual_AN5				0x0A00
                     <      	.define C_ADC_Manual_AN6				0x0C00
                     <      	.define C_ADC_Manual_AN7				0x0E00
                     <      	// Bit[13:12] : Timer select for auto scan mode
                     <      	.define C_ADC_Manual					0x0000
                     <      	.define C_ADC_Timer_A					0x1000
                     <      	.define C_ADC_Timer_B					0x2000
                     <      	.define C_ADC_Timer_C					0x3000
                     <      	// Bit14 : Auto scan busy (read only)
                     <      	.define C_ADC_Auto_Scan_Busy			0x4000
                     <      	// Bit15 : ADC busy (read only)
                     <      	.define C_ADC_Busy						0x8000
                     <      	
                     <      	//====================================================================================
                     <      	// P_ADC_LineIn_BitCtrl (0x2072)
                     <      	//====================================================================================
                     <      	.define	C_ADC_Linein_Enable				0x00FF
                     <      	.define	C_ADC_AN0_Enable				0x0001
                     <      	.define	C_ADC_AN1_Enable				0x0002
                     <      	.define	C_ADC_AN2_Enable				0x0004
                     <      	.define	C_ADC_AN3_Enable				0x0008
                     <      	.define	C_ADC_AN4_Enable				0x0010
                     <      	.define	C_ADC_AN5_Enable				0x0020
                     <      	.define	C_ADC_AN6_Enable				0x0040
                     <      	.define	C_ADC_AN7_Enable				0x0080
                     <      	
                     <      	//====================================================================================
                     <      	// P_Flash_Ctrl (0x26FF)
                     <      	//====================================================================================
                     <      	.define C_Flash_Enable_Access_CMD		0xAAAA
                     <      	.define C_Flash_PageErase_CMD			0x5511
                     <      	.define C_Flash_Program_CMD				0x5533
                     <      	
                     <      	//====================================================================================
                     <      	// Bits Definition
                     <      	//====================================================================================
                     <      	.define	C_Bit0							0x0001
                     <      	.define	C_Bit1							0x0002
                     <      	.define	C_Bit2							0x0004
                     <      	.define	C_Bit3							0x0008
                     <      	.define	C_Bit4							0x0010
                     <      	.define	C_Bit5							0x0020
                     <      	.define	C_Bit6							0x0040
                     <      	.define	C_Bit7							0x0080
                     <      	.define	C_Bit8							0x0100
                     <      	.define	C_Bit9							0x0200
                     <      	.define	C_Bit10							0x0400
                     <      	.define	C_Bit11							0x0800
                     <      	.define	C_Bit12							0x1000
                     <      	.define	C_Bit13							0x2000
                     <      	.define	C_Bit14							0x4000
                     <      	.define	C_Bit15							0x8000
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	
                     <      	
                            	
                            	//**************************************************************************
                            	// Contant Defintion Area
                            	//**************************************************************************
                            	//Using IOB as SPI interface
                            	.define	P_SPI_Data					P_IOB_Data
                            	.define	P_SPI_Buffer				P_IOB_Buffer
                            	.define	P_SPI_Dir					P_IOB_Dir
                            	.define	P_SPI_Attrib				P_IOB_Attrib
                            	//----------- SPI Hardware Port Definition -------------
                            	//----------------------------------------------------------------
                            	//Control I/O:
                            	//	  IOB12  ---------  CS
                            	//	  IOB13  ---------  SCK
                            	//    IOB14  ---------  DI
                            	//    IOB15  ---------  DO
                            	//----------------------------------------------------------------
                            	.define B_SPI_DO	0x8000
                            	.define B_SPI_DI	0x4000
                            	.define B_SPI_SCK	0x2000
                            	.define B_SPI_CS	0x1000
                            	
                            	//----------- Flash Operation Command Definition -------
                            	.define C_SPI_Flash_Read_CMD		0x03
                            	//.define C_SPI_Flash_Sector_Erase	0xD8
                            	.define C_SPI_Flash_Sector_Erase	0x20
                            	
                            	.define C_SPI_Flash_Chip_Erase		0x60
                            	.define C_SPI_Flash_Page_Program	0x02
                            	.define C_SPI_Flash_Read_Status		0x05
                            	.define C_SPI_Flash_Write_Status	0x01
                            	.define C_SPI_Flash_Write_Enable	0x06
                            	.define C_SPI_Flash_Write_Disable	0x04
                            	.define C_SPI_Flash_Read_ID			0x9F
                            	.define C_SPI_Flash_Fast_Read		0x0B
                            	.define C_SPI_Flash_Power_Down		0xB9
                            	.define C_SPI_Flash_Release_DP		0xAB
                            	.define C_SPI_Flash_Enter_4K		0xA5
                            	.define C_SPI_Flash_Exit_4K			0xB5
                            	.define C_SPI_Flash_Read_ES			0xAB
                            	.define C_SPI_Flash_Read_EMS		0x90
                            	.define C_SPI_Flash_Parallel_Mode	0x55
                            	
                            	//----------- Flash Status Port Definition ----------
                            	.define C_Flash_Busy				0x01
                            	.define C_Flash_WEL					0x02		// Write Enable Latch
                            	.define C_Flash_BP0					0x04
                            	.define C_Flash_BP1					0x08
                            	.define C_Flash_BP2					0x10
                            	.define C_Flash_BP3					0x20		
                            	.define C_Flash_PEE					0x40		// Program Erase Error
                            	.define C_Flash_SRWP				0x80		// Status Register Write Protect
                            	//.define C_SPI_BufferSize	128 // be same as that defined in "sacm_DVR4800_user.asm"
                            	
                            	//**************************************************************************
                            	// Variable Publication Area
                            	//**************************************************************************
                            	
                            	//**************************************************************************
                            	// Function Call Publication Area
                            	//**************************************************************************
                            	.public  _SPI_Initial
                            	.public F_SPI_Initial
                            	.public  _SPI_ReadAByte
                            	.public	F_SPI_ReadAByte
                            	.public  _SPI_ReadAWord
                            	.public	F_SPI_ReadAWord
                            	.public  _SPI_ReadNWords
                            	.public F_SPI_ReadNWords
                            	.public  _SPI_SendNWords
                            	.public F_SPI_SendNWords
                            	.public  _Flash_Write_Enable
                            	.public F_Flash_Write_Enable
                            	.public  _Flash_Write_Disable
                            	.public F_Flash_Write_Disable
                            	.public  _SPI_Read_Status_Register
                            	.public F_SPI_Read_Status_Register
                            	.public  _SPI_Enable_Write_Status_Register
                            	.public F_SPI_Enable_Write_Status_Register
                            	.public  _SPI_Write_Status_Register
                            	.public F_SPI_Write_Status_Register	
                            	.public  _SPI_Flash_Sector_Erase
                            	.public F_SPI_Flash_Sector_Erase
                            	.public  _SPI_Flash_Chip_Erase
                            	.public F_SPI_Flash_Chip_Erase
                            	.public  _SPI_Read_Flash_ID
                            	.public F_SPI_Read_Flash_ID
                            	.public  _SPI_SendAWord
                            	.public F_SPI_SendAWord
                            	
                            	
                            	//**************************************************************************
                            	// External Variable Declaration
                            	//**************************************************************************
                            	.external EXT_FLASH_PtrL
                            	.external EXT_FLASH_PtrH
                            	
                            	//**************************************************************************
                            	// External Function Declaration
                            	//**************************************************************************
                            	
                            	//**************************************************************************
                            	// External Table Declaration
                            	//**************************************************************************
                            	
                            	//**************************************************************************
                            	// RAM Definition Area
                            	//**************************************************************************
                            	
                            	//*****************************************************************************
                            	// Table Definition Area
                            	//*****************************************************************************
                            	
                            	
                            	//**************************************************************************
                            	// CODE Definition Area
                            	//**************************************************************************
00000000                    	.CODE
                            	//****************************************************************
                            	// Function    : F_SPI_Initial
                            	// Description : Initial SPI interface
                            	// Destory     : R1
                            	// Parameter   : None
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Initial: .proc
                            	F_SPI_Initial:
00000000 88 D2              		push R1 to [SP];
                            	// set CS as output buffer high (1,1,1)
                            	// set SCK as output buffer low (1,1,0)
                            	// set DI as input floating (0,1,1)
                            	// set DO as output buffer low (1,1,0)
00000001 11 93 06 20        		R1 = [P_SPI_Dir];
00000003 09 A3 00 B0        		R1 |= B_SPI_CS | B_SPI_SCK | B_SPI_DO;
00000005 09 B3 FF BF        		R1 &= ~B_SPI_DI;
00000007 19 D3 06 20        		[P_SPI_Dir] = R1;
                            	
00000009 11 93 07 20        		R1 = [P_SPI_Attrib];
0000000B 09 A3 00 F0        		R1 |= B_SPI_CS | B_SPI_SCK | B_SPI_DI | B_SPI_DO;
0000000D 19 D3 07 20        		[P_SPI_Attrib] = R1;
                            	
0000000F 11 93 04 20        		R1 = [P_SPI_Data];
00000011 09 A3 00 50        		R1 |= B_SPI_CS | B_SPI_DI;
00000013 09 B3 FF 5F        		R1 &= ~(B_SPI_SCK | B_SPI_DO);
00000015 19 D3 04 20        		[P_SPI_Data] = R1;
00000017 88 90              		pop R1 from [SP];
00000018 90 9A              		retf;
                            		.endp
                            	
                            	//************************************************************************
                            	// Function:  F_SPI_ReadAByte
                            	// Description: Read A Byte from SPI Flash
                            	// Syntax: 
                            	// Parameter:   R1:Address Low Word, R2:Address High Word
                            	// Return:      R1
                            	//************************************************************************
                            	_SPI_ReadAByte: .PROC
00000019 08 05 03 00        		R2 = SP + 3;
0000001B D2 92              		R1 = [R2++];
0000001C C2 94              		R2 = [R2];
                            	F_SPI_ReadAByte:
0000001D 98 D8              		push R2, R4 to [SP];
                            	//	R1--input FLASH low,mid address
                            	//	R2--input FLASH hi address
0000001E 13 97 05 20        		R3 = [P_SPI_Buffer];
00000020 0B B7 FF EF        		R3 &= ~B_SPI_CS;
00000022 1B D7 04 20        		[P_SPI_Data] = R3;
00000024 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
00000026 1B D7 04 20        		[P_SPI_Data] = R3;
                            	
00000028 01 97              		R3 = R1;	
00000029 43 92              		R1 = C_SPI_Flash_Read_CMD;
0000002A 40 F0 45 00        		call F_SPI_Send;
0000002C 02 93              		R1 = R2;
0000002D 40 F0 45 00        		call F_SPI_Send;
0000002F 7B 93              		R1 = R3 lsr 4;
00000030 79 93              		R1 = R1 lsr 4;
00000031 40 F0 45 00        		call F_SPI_Send;
00000033 0B B3 FF 00        		R1 = R3 & 0x00FF;
00000035 40 F0 45 00        		call F_SPI_Send;
00000037 40 F0 62 00        		call F_SPI_Read;
00000039 12 95 05 20        		R2 = [P_SPI_Buffer];
0000003B 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
0000003D 1A D5 04 20        		[P_SPI_Data] = R2;
0000003F 0A A5 00 10        		R2 |= B_SPI_CS;
00000041 1A D5 04 20        		[P_SPI_Data] = R2;
00000043 98 92              		pop R2, R4 from [SP];
00000044 90 9A              		retf;
                            		.endp;
                            	
                            	//************************************************************************
                            	// Function:  F_SPI_Send
                            	// Description: Send 8-bit data to SPI
                            	// Syntax: 
                            	// Parameter:   R1:Low byte data which is sent to SPI
                            	// Return:      None
                            	//************************************************************************
                            	F_SPI_Send:
00000045 98 D6              		push R1, R3 to [SP];
00000046 0A 95 80 00        		R2 = 0x80;
                            	?L_Send_Data_Loop:
00000048 13 97 05 20        		R3 = [P_SPI_Buffer];
0000004A 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
0000004C 1B D7 04 20        		[P_SPI_Data] = R3;
0000004E 01 C5              		test R2, R1;
0000004F 03 4E              		jnz ?L_Send_One;
00000050 0B B7 FF 7F        		R3 &= ~B_SPI_DO;
00000052 05 EE              		jmp ?L_Send_Bit_Ready;
                            	?L_Send_One:
00000053 0B A7 00 80        		R3 |= B_SPI_DO;
00000055 65 F1              		nop;
00000056 65 F1              		nop;
00000057 65 F1              		nop;
                            	?L_Send_Bit_Ready:
00000058 1B D7 04 20        		[P_SPI_Data] = R3;
0000005A 0B A7 00 20        		R3 |= B_SPI_SCK;
0000005C 1B D7 04 20        		[P_SPI_Data] = R3;
0000005E 62 95              		R2 = R2 lsr 1;
0000005F 58 4E              		jnz ?L_Send_Data_Loop;
00000060 98 90              		pop R1, R3 from [SP];
00000061 90 9A              		retf;
                            	
                            	//************************************************************************
                            	// Function:  F_SPI_Read
                            	// Description: Read 8-bit data from SPI
                            	// Syntax: 
                            	// Parameter:   None
                            	// Return:      R1:Low byte data which is read from SPI
                            	//************************************************************************
                            	F_SPI_Read:
00000062 90 D6              		push R2, R3 to [SP];
00000063 40 92              		R1 = 0;
00000064 48 94              		R2 = 8;
                            	?L_Read_Data_Loop:
00000065 13 97 05 20        		R3 = [P_SPI_Buffer];
00000067 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
00000069 1B D7 04 20        		[P_SPI_Data] = R3;
0000006B 65 F1              		nop;
0000006C 65 F1              		nop;
0000006D 65 F1              		nop;
0000006E 0B A7 00 20        		R3 |= B_SPI_SCK;
00000070 1B D7 04 20        		[P_SPI_Data] = R3;
00000072 13 97 04 20        		R3 = [P_SPI_Data];
00000074 0B C7 00 40        		test R3, B_SPI_DI;
00000076 01 5E              		jz ?L_CheckBitNumber;
00000077 41 A2              		R1 |= 0x0001;
                            	?L_CheckBitNumber:
00000078 41 24              		R2 -= 1;
00000079 02 5E              		jz ?L_Read_Data_End;
0000007A 41 93              		R1 = R1 lsl 1;
0000007B 57 EE              		jmp ?L_Read_Data_Loop;
                            	?L_Read_Data_End:
0000007C 90 92              		pop R2, R3 from [SP];
0000007D 90 9A              		retf;
                            	
                            	//************************************************************************
                            	// Function:  F_SPI_ReadAWord
                            	// Description: Read A Word from SPI Flash
                            	// Syntax: 
                            	// Parameter:   R1:Address Low Word, R2:Address High Word
                            	// Return:      R1
                            	//************************************************************************
                            	_SPI_ReadAWord:	.proc
0000007E 08 05 03 00        		R2 = SP + 3;
00000080 D2 92              		R1 = [R2++];
00000081 C2 94              		R2 = [R2];
                            	F_SPI_ReadAWord:
00000082 98 D8              		push R2, R4 to [SP];
                            	//	R1--input FLASH low,mid address
                            	//	R2--input FLASH hi address
00000083 13 97 05 20        		R3 = [P_SPI_Buffer];
00000085 0B B7 FF EF        		R3 &= ~B_SPI_CS;
00000087 1B D7 04 20        		[P_SPI_Data] = R3;
00000089 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
0000008B 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
0000008D 01 97              		R3 = R1;
0000008E 43 92              		R1 = C_SPI_Flash_Read_CMD;
0000008F 40 F0 45 00        		call F_SPI_Send;
00000091 02 93              		R1 = R2;
00000092 40 F0 45 00        		call F_SPI_Send;
00000094 7B 93              		R1 = R3 lsr 4;
00000095 79 93              		R1 = R1 lsr 4;
00000096 40 F0 45 00        		call F_SPI_Send;
00000098 03 93              		R1 = R3;
00000099 40 F0 45 00        		call F_SPI_Send;
0000009B 40 F0 62 00        		call F_SPI_Read;
0000009D 01 99              		R4 = R1;
0000009E 40 F0 62 00        		call F_SPI_Read;
000000A0 59 93              		R1 = R1 lsl 4;
000000A1 59 93              		R1 = R1 lsl 4;
000000A2 04 A3              		R1 |= R4;	
000000A3 12 95 05 20        		R2 = [P_SPI_Buffer];
000000A5 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
000000A7 1A D5 04 20        		[P_SPI_Data] = R2;
000000A9 0A A5 00 10        		R2 |= B_SPI_CS;
000000AB 1A D5 04 20        		[P_SPI_Data] = R2;
                            		
000000AD 98 92              		pop R2, R4 from [SP];
000000AE 90 9A              		retf;
                            		.endp;
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_ReadNWords
                            	// Description : Get N words from external memory to buffer
                            	// Destory     : R1, R2, R3, R4
                            	// Parameter   : R1 : buffer address
                            	//               R2 : data length
                            	//               R3 : external memory address low word
                            	//               R4 : external memory address high word
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_ReadNWords:	.proc
000000AF 08 09 03 00        	    R4 = SP + 3;
000000B1 D4 92              	    R1 = [R4++];							// buffer address
000000B2 D4 94              	    R2 = [R4++];							// data length
000000B3 D4 96              	    R3 = [R4++];							// external memory address low byte
000000B4 C4 98              	    R4 = [R4];							// external memory address high byte
                            	F_SPI_ReadNWords:
000000B5 A8 DA              		push R1, R5 to [SP];
000000B6 15 9B 05 20        		R5 = [P_SPI_Buffer];		// set CS low
000000B8 0D BB FF EF        		R5 &= ~B_SPI_CS;
000000BA 1D DB 04 20        		[P_SPI_Data] = R5;
000000BC 0D BB FF DF        		R5 &= ~B_SPI_SCK;
000000BE 1D DB 04 20        		[P_SPI_Data] = R5;
                            	
000000C0 01 9B              		R5 = R1;
000000C1 43 92              		R1 = C_SPI_Flash_Read_CMD;
000000C2 40 F0 45 00        		call F_SPI_Send;
000000C4 04 93              		R1 = R4;					// address high byte
000000C5 40 F0 45 00        		call F_SPI_Send;
000000C7 03 93              		R1 = R3;					// address middle byte
000000C8 79 93              		R1 = R1 lsr 4;
000000C9 79 93              		R1 = R1 lsr 4;
000000CA 40 F0 45 00        		call F_SPI_Send;
000000CC 03 93              		R1 = R3;					// address low byte
000000CD 40 F0 45 00        		call F_SPI_Send;
                            	?L_ReadDataLoop:
000000CF 40 F0 62 00        		call F_SPI_Read;
000000D1 01 99              		R4 = R1;
000000D2 40 F0 62 00        		call F_SPI_Read;
000000D4 59 93              		R1 = R1 lsl 4;
000000D5 59 93              		R1 = R1 lsl 4;
000000D6 04 A3              		R1 |= R4;	
000000D7 D5 D2              		[R5++] = R1;
000000D8 41 24              		R2 -= 1;
000000D9 4B 4E              		jnz ?L_ReadDataLoop;
000000DA 12 95 05 20        		R2 = [P_SPI_Buffer];
000000DC 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
000000DE 1A D5 04 20        		[P_SPI_Data] = R2;
000000E0 0A A5 00 10        		R2 |= B_SPI_CS;
000000E2 1A D5 04 20        		[P_SPI_Data] = R2;
                            		
000000E4 A8 90              		pop R1, R5 from [SP];
000000E5 90 9A              		retf;
                            		.endp;
                            	
                            	//****************************************************************
                            	// Function    : F_Flash_Write_Enable
                            	// Description : Enable flash to be written or erased
                            	// Destory     : R1, R2, R3
                            	// Parameter   : None
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_Flash_Write_Enable:	.proc
                            	F_Flash_Write_Enable:
000000E6 98 D6              		push R1, R3 to [SP];
000000E7 13 97 05 20        		R3 = [P_SPI_Buffer];
000000E9 0B B7 FF EF        		R3 &= ~B_SPI_CS;
000000EB 1B D7 04 20        		[P_SPI_Data] = R3;
000000ED 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
000000EF 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
000000F1 46 92              		R1 = C_SPI_Flash_Write_Enable;
000000F2 40 F0 45 00        		call F_SPI_Send;
                            	
000000F4 12 95 05 20        		R2 = [P_SPI_Buffer];
000000F6 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
000000F8 1A D5 04 20        		[P_SPI_Data] = R2;
000000FA 0A A5 00 10        		R2 |= B_SPI_CS;
000000FC 1A D5 04 20        		[P_SPI_Data] = R2;
000000FE 98 90              		pop R1, R3 from [SP];
000000FF 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_Flash_Write_Disable
                            	// Description : Disable flash to be written or erased
                            	// Destory     : R1, R2, R3
                            	// Parameter   : None
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_Flash_Write_Disable:	.proc
                            	F_Flash_Write_Disable:
00000100 98 D6              		push R1, R3 to [SP];
00000101 13 97 05 20        		R3 = [P_SPI_Buffer];
00000103 0B B7 FF EF        		R3 &= ~B_SPI_CS;
00000105 1B D7 04 20        		[P_SPI_Data] = R3;
00000107 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
00000109 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
0000010B 44 92              		R1 = C_SPI_Flash_Write_Disable;
0000010C 40 F0 45 00        		call F_SPI_Send;
                            	
0000010E 12 95 05 20        		R2 = [P_SPI_Buffer];
00000110 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
00000112 1A D5 04 20        		[P_SPI_Data] = R2;
00000114 0A A5 00 10        		R2 |= B_SPI_CS;
00000116 1A D5 04 20        		[P_SPI_Data] = R2;
00000118 98 90              		pop R1, R3 from [SP];
00000119 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_Read_Status_Register
                            	// Description : Read status register in flash
                            	// Destory     : R1, R2, R3
                            	// Parameter   : None
                            	// Return      : R1 = Value of Status Register
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Read_Status_Register:	.proc
                            	F_SPI_Read_Status_Register:
0000011A 90 D6              		push R2, R3 to [SP];
0000011B 13 97 05 20        		R3 = [P_SPI_Buffer];
0000011D 0B B7 FF EF        		R3 &= ~B_SPI_CS;
0000011F 1B D7 04 20        		[P_SPI_Data] = R3;
00000121 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
00000123 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
00000125 45 92              		R1 = C_SPI_Flash_Read_Status;
00000126 40 F0 45 00        		call F_SPI_Send;
00000128 40 F0 62 00        		call F_SPI_Read;			// Return Status Register
                            		
0000012A 12 95 05 20        		R2 = [P_SPI_Buffer];
0000012C 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
0000012E 1A D5 04 20        		[P_SPI_Data] = R2;
00000130 0A A5 00 10        		R2 |= B_SPI_CS;
00000132 1A D5 04 20        		[P_SPI_Data] = R2;
00000134 90 92              		pop R2, R3 from [SP];
00000135 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_Enable_Write_Status_Register
                            	// Description : Enable status register in flash to be written
                            	// Destory     : R1, R2, R3
                            	// Parameter   : None
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Enable_Write_Status_Register:	.proc
                            	F_SPI_Enable_Write_Status_Register:
00000136 98 D6              		push R1, R3 to [SP];
00000137 13 97 05 20        		R3 = [P_SPI_Buffer];
00000139 0B B7 FF EF        		R3 &= ~B_SPI_CS;
0000013B 1B D7 04 20        		[P_SPI_Data] = R3;
0000013D 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
0000013F 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
00000141 41 92              		R1 = C_SPI_Flash_Write_Status;
00000142 40 F0 45 00        		call F_SPI_Send;
                            	
00000144 12 95 05 20        		R2 = [P_SPI_Buffer];
00000146 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
00000148 1A D5 04 20        		[P_SPI_Data] = R2;
0000014A 0A A5 00 10        		R2 |= B_SPI_CS;
0000014C 1A D5 04 20        		[P_SPI_Data] = R2;
0000014E 98 90              		pop R1, R3 from [SP];
0000014F 90 9A              		retf;
                            		.endp
                            		
                            	//****************************************************************
                            	// Function    : F_SPI_Write_Status_Register
                            	// Description : Write data to status register in flash 
                            	// Destory     : R1, R2, R3
                            	// Parameter   : R1 = Data to be written into Status Register
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Write_Status_Register:	.proc
00000150 08 03 03 00        		R1 = SP + 3;
00000152 C1 92              		R1 = [R1];
                            	F_SPI_Write_Status_Register:
00000153 98 D6              		push R1, R3 to [SP];
00000154 13 97 05 20        		R3 = [P_SPI_Buffer];
00000156 0B B7 FF EF        		R3 &= ~B_SPI_CS;
00000158 1B D7 04 20        		[P_SPI_Data] = R3;
0000015A 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
0000015C 1B D7 04 20        		[P_SPI_Data] = R3;
                            	
0000015E 01 95              		R2 = R1;	
0000015F 41 92              		R1 = C_SPI_Flash_Write_Status;
00000160 40 F0 45 00        		call F_SPI_Send;
00000162 0A B3 FF 00        		R1 = R2 & 0x00FF;
00000164 40 F0 45 00        		call F_SPI_Send;
                            	
00000166 12 95 05 20        		R2 = [P_SPI_Buffer];
00000168 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
0000016A 1A D5 04 20        		[P_SPI_Data] = R2;
0000016C 0A A5 00 10        		R2 |= B_SPI_CS;
0000016E 1A D5 04 20        		[P_SPI_Data] = R2;
00000170 98 90              		pop R1, R3 from [SP];
00000171 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_Flash_Sector_Erase
                            	// Description : Erase one sector of flash
                            	// Destory     : R1, R2, R3, R4
                            	// Parameter   : R1 = Sector Address Low, R2 = Sector Address High
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Flash_Sector_Erase:	.proc
00000172 08 03 03 00        		R1 = SP + 3;
00000174 C1 92              		R1 = [R1];
                            	F_SPI_Flash_Sector_Erase:
00000175 A8 DA              		push R1, R5 to [SP];
00000176 40 F0 E6 00        		call F_Flash_Write_Enable;	// Enable sector erase command 
                            	.if 0		// for GPR25L005, GPR25L010, GPR25L020, GPR25L040, GPR25L080
                            		R2 = SECTOR_SIZE;
                            		MR = R1 * R2;
                            		R1 = R3;
                            		R2 = R4;
                            	.endif
                            	
                            	.if 1		// for GPR25L160, GPR25L320, GPR25L640
00000178 01 95              		R2 = R1;
00000179 40 92              		R1 = 0x0000;
                            	.endif
                            	
0000017A 13 97 05 20        		R3 = [P_SPI_Buffer];
0000017C 0B B7 FF EF        		R3 &= ~B_SPI_CS;
0000017E 1B D7 04 20        		[P_SPI_Data] = R3;
00000180 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
00000182 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
00000184 01 9B              		R5 = R1;
00000185 60 92              		R1 = C_SPI_Flash_Sector_Erase;
00000186 40 F0 45 00        		call F_SPI_Send;
00000188 02 93              		R1 = R2;
00000189 40 F0 45 00        		call F_SPI_Send;
0000018B 7D 93              		R1 = R5 lsr 4;
0000018C 7D 93              		R1 = R5 lsr 4;
0000018D 40 F0 45 00        		call F_SPI_Send;
0000018F 0D B3 FF 00        		R1 = R5 & 0x00FF;
00000191 40 F0 45 00        		call F_SPI_Send;
                            	
00000193 12 95 05 20        		R2 = [P_SPI_Buffer];
00000195 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
00000197 1A D5 04 20        		[P_SPI_Data] = R2;
00000199 0A A5 00 10        		R2 |= B_SPI_CS;
0000019B 1A D5 04 20        		[P_SPI_Data] = R2;
                            		
                            	?L_Check_Busy:					// Wait untill sector has been erased successfully (about 1 to 3 seconds)
0000019D 41 92              		R1 = 0x0001;
0000019E 19 D3 34 20        	    [P_Watchdog_Clear] = R1;
000001A0 40 F0 1A 01        		call F_SPI_Read_Status_Register;
000001A2 41 C2              		test R1, C_Flash_Busy;
000001A3 47 4E              		jnz ?L_Check_Busy;
                            	
000001A4 A8 90              		pop R1, R5 from [SP];
000001A5 90 9A              		retf;	
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_Flash_Chip_Erase
                            	// Description :  Erase hole chip of flash 
                            	// Destory     : R1, R2, R3
                            	// Parameter   : None
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Flash_Chip_Erase:	.proc
                            	F_SPI_Flash_Chip_Erase:
000001A6 98 D6              		push R1, R3 to [SP];
000001A7 40 F0 E6 00        		call F_Flash_Write_Enable;		// Enable chip erase command 
000001A9 13 97 05 20        		R3 = [P_SPI_Buffer];
000001AB 0B B7 FF EF        		R3 &= ~B_SPI_CS;
000001AD 1B D7 04 20        		[P_SPI_Data] = R3;
000001AF 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
000001B1 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
000001B3 09 93 60 00        		R1 = C_SPI_Flash_Chip_Erase;
000001B5 40 F0 45 00        		call F_SPI_Send;
                            	
000001B7 12 95 05 20        		R2 = [P_SPI_Buffer];
000001B9 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
000001BB 1A D5 04 20        		[P_SPI_Data] = R2;
000001BD 0A A5 00 10        		R2 |= B_SPI_CS;
000001BF 1A D5 04 20        		[P_SPI_Data] = R2;
                            		
                            	?L_Check_Busy:						// Wait untill chip has been erased successfully (about 128 to 256 seconds)
000001C1 41 92              		R1 = 0x0001;
000001C2 19 D3 34 20        	    [P_Watchdog_Clear] = R1;
000001C4 40 F0 1A 01        		call F_SPI_Read_Status_Register;
000001C6 41 C2              		test R1, C_Flash_Busy;
000001C7 47 4E              		jnz ?L_Check_Busy;
000001C8 98 90              		pop R1, R3 from [SP];
000001C9 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_Read_Flash_ID
                            	// Description : Read flash manufacturer,memory and individual device ID 
                            	// Destory     : R1, R2, R3
                            	// Parameter   : None
                            	// Return      : R1 = Manufacturer and memory ID, R2 = Individual Device ID
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_Read_Flash_ID:	.proc
                            	F_SPI_Read_Flash_ID:
000001CA 90 D6              		push R2, R3 to [SP];
000001CB 13 97 05 20        		R3 = [P_SPI_Buffer];
000001CD 0B B7 FF EF        		R3 &= ~B_SPI_CS;
000001CF 1B D7 04 20        		[P_SPI_Data] = R3;
000001D1 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
000001D3 1B D7 04 20        		[P_SPI_Data] = R3;
                            		
000001D5 09 93 9F 00        		R1 = C_SPI_Flash_Read_ID;
000001D7 40 F0 45 00        		call F_SPI_Send;
000001D9 40 F0 62 00        		call F_SPI_Read;			// Read Manufacturer ID
000001DB 88 D2              		push R1 to [SP];
000001DC 40 F0 62 00        		call F_SPI_Read;			// Read Memory ID
000001DE 88 D2              		push R1 to [SP];
000001DF 40 F0 62 00        		call F_SPI_Read;			// Read Individual Device ID
000001E1 01 95              		R2 = R1;					// Return Individual Device ID
000001E2 88 94              		pop R3 from [SP];
000001E3 88 90              		pop R1 from [SP];
000001E4 5B 97              		R3 = R3 lsl 4;
000001E5 5B 97              		R3 = R3 lsl 4;
000001E6 03 A3              		R1 |= R3;					// Return Memory ID and Manufacturer ID
                            	
000001E7 13 97 05 20        		R3 = [P_SPI_Buffer];
000001E9 0B B7 FF DF        		R3 &= ~B_SPI_SCK;
000001EB 1B D7 04 20        		[P_SPI_Data] = R3;
000001ED 0B A7 00 10        		R3 |= B_SPI_CS;
000001EF 1B D7 04 20        		[P_SPI_Data] = R3;
000001F1 90 92              		pop R2, R3 from [SP];
000001F2 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_SendAWord
                            	// Description : Write a word data to flash
                            	// Destory     : R1, R2, R3
                            	// Parameter   : R1 = Address Low, R2 = Address High, R3 = one word of data
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	_SPI_SendAWord:	.proc
000001F3 08 07 03 00        		R3 = SP + 3;
000001F5 D3 92              		R1 = [R3++];
000001F6 D3 94              		R2 = [R3++];
000001F7 C3 96              		R3 = [R3];
                            	F_SPI_SendAWord:
000001F8 A0 D8              		push R1, R4 to [SP];
000001F9 40 F0 E6 00        		call F_Flash_Write_Enable;
000001FB 14 99 05 20        		R4 = [P_SPI_Buffer];
000001FD 0C B9 FF EF        		R4 &= ~B_SPI_CS;
000001FF 1C D9 04 20        		[P_SPI_Data] = R4;
00000201 0C B9 FF DF        		R4 &= ~B_SPI_SCK;
00000203 1C D9 04 20        		[P_SPI_Data] = R4;
                            		
00000205 01 99              		R4 = R1;
00000206 42 92              		R1 = C_SPI_Flash_Page_Program;
00000207 40 F0 45 00        		call F_SPI_Send;
00000209 02 93              		R1 = R2;
0000020A 40 F0 45 00        		call F_SPI_Send;
0000020C 7C 93              		R1 = R4 lsr 4;
0000020D 79 93              		R1 = R1 lsr 4;
0000020E 40 F0 45 00        		call F_SPI_Send;
00000210 0C B3 FF 00        		R1 = R4 & 0xFF;
00000212 40 F0 45 00        		call F_SPI_Send;
00000214 0B B3 FF 00        		R1 = R3 & 0x00FF;
00000216 40 F0 45 00        		call F_SPI_Send;
00000218 7B 93              		R1 = R3 lsr 4;
00000219 79 93              		R1 = R1 lsr 4;
0000021A 40 F0 45 00        		call F_SPI_Send; 
                            	
0000021C 12 95 05 20        		R2 = [P_SPI_Buffer];
0000021E 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
00000220 1A D5 04 20        		[P_SPI_Data] = R2;
00000222 0A A5 00 10        		R2 |= B_SPI_CS;
00000224 1A D5 04 20        		[P_SPI_Data] = R2;
                            	
                            	?L_Check_Busy:						// Wait untill one word data has been written into flash successfully (about 3 to 12ms).
00000226 40 F0 1A 01        		call F_SPI_Read_Status_Register; // WatchDog overflow can escape from dead loop
00000228 41 C2              		test R1, C_Flash_Busy;
00000229 44 4E              		jnz ?L_Check_Busy;	
                            	
0000022A A0 90              		pop R1, R4 from [SP];
0000022B 90 9A              		retf;
                            		.endp
                            	
                            	//****************************************************************
                            	// Function    : F_SPI_SendNWords
                            	// Description : Send N words to external memory from internal buffer
                            	// Destory     : None
                            	// Parameter   : R1 : buffer address
                            	//               R2 : data length
                            	//               R3 : external memory address low word
                            	//               R4 : external memory address high word
                            	// Return      : None
                            	// Note        : None
                            	//****************************************************************
                            	 _SPI_SendNWords:	.proc
0000022C 08 09 04 00        		R4 = SP + 4;
0000022E D4 92              		R1 = [R4++];
0000022F D4 94              		R2 = [R4++];
00000230 D4 96              		R3 = [R4++];
00000231 C4 98              		R4 = [R4];
                            	F_SPI_SendNWords:
00000232 A8 DA              		push R1, R5 to [SP];
                            	
                            	?L_WriteData:
00000233 40 F0 E6 00        		call F_Flash_Write_Enable;
00000235 15 9B 05 20        		R5 = [P_SPI_Buffer];
00000237 0D BB FF EF        		R5 &= ~B_SPI_CS;
00000239 1D DB 04 20        		[P_SPI_Data] = R5;
0000023B 0D BB FF DF        		R5 &= ~B_SPI_SCK;
0000023D 1D DB 04 20        		[P_SPI_Data] = R5;
                            		
0000023F 01 9B              		R5 = R1;
00000240 42 92              		R1 = C_SPI_Flash_Page_Program;
00000241 40 F0 45 00        		call F_SPI_Send;
00000243 0C B3 FF 00        		R1 = R4 & 0x00FF;
00000245 40 F0 45 00        		call F_SPI_Send;
00000247 7B 93              		R1 = R3 lsr 4;			// Address Middle byte
00000248 79 93              		R1 = R1 lsr 4;
00000249 40 F0 45 00        		call F_SPI_Send;
0000024B 0B B3 FF 00        		R1 = R3 & 0x00FF;		// Address low byte
0000024D 40 F0 45 00        		call F_SPI_Send;
                            	
                            	?L_SendDataLoop:
0000024F D5 92              		R1 = [R5++];
00000250 40 F0 45 00        		call F_SPI_Send;
00000252 79 93              		R1 = R1 lsr 4;
00000253 79 93              		R1 = R1 lsr 4;
00000254 40 F0 45 00        		call F_SPI_Send;
00000256 41 24              		R2 -= 1;
00000257 18 5E              		jz ?L_SendDataEnd;
00000258 42 06              		R3 += 2;
00000259 0B C7 FF 00        		test R3, 0x00FF;
0000025B 4D 4E              		jnz ?L_SendDataLoop;
                            	?L_JumpToNextPage:
0000025C 40 46              		cmp R3, 0x0000;
0000025D 01 4E              		jne ?L_WriteCurrentPage;
0000025E 41 08              		R4 += 1;
                            	?L_WriteCurrentPage:
                            	//	setb [P_IOB_Data], C_SPI_CS_IO;	// disable SPI Flash
0000025F 11 93 05 20        		R1 = [P_SPI_Buffer];
00000261 09 B3 FF DF        		R1 &= ~B_SPI_SCK;
00000263 19 D3 04 20        		[P_SPI_Data] = R1;
00000265 09 A3 00 10        		R1 |= B_SPI_CS;
00000267 19 D3 04 20        		[P_SPI_Data] = R1;
                            	
                            	?L_Check_Busy_1:					// Wait untill one word data has been written into flash successfully (about 3 to 12ms).
00000269 40 F0 1A 01        		call F_SPI_Read_Status_Register; // WatchDog overflow can escape from dead loop
0000026B 41 C2              		test R1, C_Flash_Busy;
0000026C 44 4E              		jnz ?L_Check_Busy_1;
0000026D 05 93              		R1 = R5;
0000026E 0F 9F 33 02        		pc = ?L_WriteData;
                            		
                            	?L_SendDataEnd:
00000270 12 95 05 20        		R2 = [P_SPI_Buffer];
00000272 0A B5 FF DF        		R2 &= ~B_SPI_SCK;
00000274 1A D5 04 20        		[P_SPI_Data] = R2;
00000276 0A A5 00 10        		R2 |= B_SPI_CS;
00000278 1A D5 04 20        		[P_SPI_Data] = R2;
                            	?L_Check_Busy:						// Wait untill one word data has been written into flash successfully (about 3 to 12ms).
0000027A 40 F0 1A 01        		call F_SPI_Read_Status_Register; // WatchDog overflow can escape from dead loop
0000027C 41 C2              		test R1, C_Flash_Busy;
0000027D 44 4E              		jnz ?L_Check_Busy;
                            	
0000027E A8 90              		pop R1, R5 from [SP];
0000027F 90 9A              		retf;
                            		.endp
0 error(s), 0 warning(s).
