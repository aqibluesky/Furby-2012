DebugLine(path):D:\WorkingFolder\Library_Release\SACMV41b_Beta\GPCE061A_Example_V41b\GPCE061A Example Code\include/
DebugLine(file):D:\WorkingFolder\Library_Release\SACMV41b_Beta\GPCE061A_Example_V41b\GPCE061A Example Code\include\SPI_Flash_CE061.asm
DebugLine(instruction):192,1,0,0,0
CommentLine:(0,1,0,0)
//==========================================================================
CommentLine:(0,2,0,0)
// File Name   : SACM_DVR4800_USER.asm
CommentLine:(0,3,0,0)
// Description : Users implement functions
CommentLine:(0,4,0,0)
// Written by  : Ray Cheng
CommentLine:(0,5,0,0)
// Last modified date:
CommentLine:(0,6,0,0)
//              2005/12/26
CommentLine:(0,7,0,0)
// Note: 
CommentLine:(0,8,0,0)
//==========================================================================
CommentLine:(0,9,0,0)
//**************************************************************************
CommentLine:(0,10,0,0)
// Header File Included Area
CommentLine:(0,11,0,0)
//**************************************************************************
DebugLine(instruction):224,1,0,0,0
IncludeLine:(0,12,0,0)
.include GPCE061.inc;
DebugLine(path):D:\WorkingFolder\Library_Release\SACMV41b_Beta\GPCE061A_Example_V41b\GPCE061A Example Code\include/
DebugLine(file):D:\WorkingFolder\Library_Release\SACMV41b_Beta\GPCE061A_Example_V41b\GPCE061A Example Code\include\GPCE061.inc
DebugLine(instruction):192,1,0,0,0
CommentLine:(1,1,0,1)
//==========================================================================
CommentLine:(1,2,0,1)
// File Name   : GPCE.inc
CommentLine:(1,3,0,1)
// Description : GPCE registers and constants definition
CommentLine:(1,4,0,1)
// Written by  : Ray Cheng
CommentLine:(1,5,0,1)
// Last modified date:
CommentLine:(1,6,0,1)
//              2005/12/26
CommentLine:(1,7,0,1)
//==========================================================================
ConditionLine:(1,8,0,1)
.ifndef __GPCE_INC__
EquLine:(1,9,0,1)
.define __GPCE_INC__
CommentLine:(1,10,0,1)
//====================================================================================
CommentLine:(1,11,0,1)
//	Port Definition
CommentLine:(1,12,0,1)
//====================================================================================
EquLine:(1,13,0,1)
.define P_IOA_Data				0x7000		// Write Data into data register and read from IOA pad
EquLine:(1,14,0,1)
.define P_IOA_Buffer			0x7001		// Write Data into buffer register and read from buffer register
EquLine:(1,15,0,1)
.define P_IOA_Dir				0x7002		// Direction vector for IOA
EquLine:(1,16,0,1)
.define P_IOA_Attrib			0x7003		// Attribute vector for IOA
EquLine:(1,17,0,1)
.define P_IOA_Latch				0x7004		// Latch PortA data for key change wake-up
CommentLine:(1,18,0,1)

EquLine:(1,19,0,1)
.define P_IOB_Data				0x7005		// Write Data into the data register and read from IOB pad
EquLine:(1,20,0,1)
.define P_IOB_Buffer			0x7006		// Write Data into buffer register and read from buffer register
EquLine:(1,21,0,1)
.define P_IOB_Dir				0x7007		// Direction vector for IOB
EquLine:(1,22,0,1)
.define P_IOB_Attrib			0x7008		// Attribute vector for IOB
CommentLine:(1,23,0,1)

EquLine:(1,24,0,1)
.define P_FeedBack				0x7009		// Clock form external R,C
EquLine:(1,25,0,1)
.define P_TimerA_Data			0x700A		// Data port for TimerA 
EquLine:(1,26,0,1)
.define P_TimerA_Ctrl			0x700B		// Control Port for TimerA
EquLine:(1,27,0,1)
.define P_TimerB_Data			0x700C		// Data port for TimerB
EquLine:(1,28,0,1)
.define P_TimerB_Ctrl			0x700D		// Control Port for TimerB
EquLine:(1,29,0,1)
.define P_TimeBase_Setup		0x700E		// TimerBase Freq. Set
EquLine:(1,30,0,1)
.define P_TimeBase_Clear		0x700F		// Reset Timerbase counter
EquLine:(1,31,0,1)
.define P_INT_Ctrl				0x7010		// for read INT flag(R)
EquLine:(1,32,0,1)
.define P_INT_Clear				0x7011		// Clear interrupt source
EquLine:(1,33,0,1)
.define P_Watchdog_Clear		0x7012		// Watchdog Reset
EquLine:(1,34,0,1)
.define P_SystemClock			0x7013		// Change system clock frequency(include go to standby mode)
CommentLine:(1,35,0,1)

EquLine:(1,36,0,1)
.define P_ADC					0x7014		// Data Port for AD
EquLine:(1,37,0,1)
.define P_ADC_Ctrl				0x7015		// Control Port for AD control
EquLine:(1,38,0,1)
.define P_ADC_Status			0x7015		// AD Port Status
EquLine:(1,39,0,1)
.define P_DAC2					0x7016		// Data Port for DAC2
EquLine:(1,40,0,1)
.define P_DAC1					0x7017		// Data Port for DAC1
EquLine:(1,41,0,1)
.define P_DAC_Ctrl				0x702A		// Control Port for two DAC and audio output mode
CommentLine:(1,42,0,1)

EquLine:(1,43,0,1)
.define P_LVD_Ctrl				0x7019		// Control Port for LVD
CommentLine:(1,44,0,1)

EquLine:(1,45,0,1)
.define P_SIO_Data				0x701A		// serial interface IO	
EquLine:(1,46,0,1)
.define P_SIO_Addr_Low			0x701B		// Address Port low
EquLine:(1,47,0,1)
.define P_SIO_Addr_Mid			0x701C		// Address Port middle
EquLine:(1,48,0,1)
.define P_SIO_Addr_High			0x701D		// Address Port high
EquLine:(1,49,0,1)
.define P_SIO_Ctrl				0x701E		// Control Port
EquLine:(1,50,0,1)
.define P_SIO_Start				0x701F		// Start port for serial interface
EquLine:(1,51,0,1)
.define P_SIO_Stop				0x7020		// Stop port for serial interface
CommentLine:(1,52,0,1)

EquLine:(1,53,0,1)
.define P_UART_Command1			0x7021		// Command1 Port for UART
EquLine:(1,54,0,1)
.define P_UART_Command2			0x7022		// Command2 Port for UART
EquLine:(1,55,0,1)
.define P_UART_Data				0x7023		// Data Port for UART
EquLine:(1,56,0,1)
.define P_UART_BaudScalarLow	0x7024		// Set Baud Rate scalar low
EquLine:(1,57,0,1)
.define P_UART_BaudScalarHigh	0x7025		// Set Baud Rate scalar high
CommentLine:(1,58,0,1)

EquLine:(1,59,0,1)
.define P_ADC_MUX_Ctrl			0x702B		// Control Port
EquLine:(1,60,0,1)
.define P_ADC_LINEIN_Data		0x702C		// Line in data
EquLine:(1,61,0,1)
.define P_INT_Mask				0x702D		//R/W INT enable/disable
EquLine:(1,62,0,1)
.define P_Flash_Ctrl			0x7555		//Internal flash access enable/disable
CommentLine:(1,63,0,1)
//----------------------------------------------
CommentLine:(1,64,0,1)

CommentLine:(1,65,0,1)
// Constants definition
CommentLine:(1,66,0,1)
// Define for P_INT_Ctrl 
EquLine:(1,67,0,1)
.define C_IRQ6_TMB2				0x0001		//Timer B IRQ6
EquLine:(1,68,0,1)
.define C_IRQ6_TMB1				0x0002		//Timer A IRQ6
EquLine:(1,69,0,1)
.define C_IRQ5_2Hz				0x0004		//2Hz IRQ5
EquLine:(1,70,0,1)
.define C_IRQ5_4Hz				0x0008		//4Hz IRQ5
EquLine:(1,71,0,1)
.define C_IRQ4_1KHz				0x0010		//1024Hz IRQ4
EquLine:(1,72,0,1)
.define C_IRQ4_2KHz				0x0020		//2048 IRQ4
EquLine:(1,73,0,1)
.define C_IRQ4_4KHz				0x0040		//4096 IRQ4
EquLine:(1,74,0,1)
.define C_IRQ3_KEY				0x0080		//Key Change IRQ3
EquLine:(1,75,0,1)
.define C_IRQ3_Ext1				0x0100		//Ext1 IRQ3
EquLine:(1,76,0,1)
.define C_IRQ3_Ext2				0x0200		//Ext2 IRQ3
EquLine:(1,77,0,1)
.define C_IRQ2_TMB				0x0400		//Timer B IRQ2
EquLine:(1,78,0,1)
.define C_FIQ_TMB				0x0800		//Timer B FIQ
EquLine:(1,79,0,1)
.define C_IRQ1_TMA				0x1000		//Timer A IRQ1
EquLine:(1,80,0,1)
.define C_FIQ_TMA				0x2000		//Timer A FIQ
EquLine:(1,81,0,1)
.define C_IRQ0_PWM				0x4000		//PWM IRQ0
EquLine:(1,82,0,1)
.define C_FIQ_PWM				0x8000		//PWM FIQ
CommentLine:(1,83,0,1)

CommentLine:(1,84,0,1)
// Define for P_TimerA_Ctrl, P_TimerB_Ctrl                               
EquLine:(1,85,0,1)
.define C_Timer_FPLL_2			0x0000		// b0--b2: clock of source A
EquLine:(1,86,0,1)
.define C_Timer_FPLL_256		0x0001		//
EquLine:(1,87,0,1)
.define C_Timer_32768Hz			0x0002		//
EquLine:(1,88,0,1)
.define C_Timer_8192Hz			0x0003		//
EquLine:(1,89,0,1)
.define C_Timer_4096Hz			0x0004		//
EquLine:(1,90,0,1)
.define C_Timer_A1				0x0005		//
EquLine:(1,91,0,1)
.define C_Timer_A0				0x0006		//
EquLine:(1,92,0,1)
.define C_Timer_Ext1			0x0007		//
CommentLine:(1,93,0,1)

EquLine:(1,94,0,1)
.define C_Timer_2048Hz			0x0000		//b3--b5: clock of source B
EquLine:(1,95,0,1)
.define C_Timer_1024Hz			0x0008		//
EquLine:(1,96,0,1)
.define C_Timer_256Hz			0x0000		//
EquLine:(1,97,0,1)
.define C_Timer_TMB1			0x0018		//
EquLine:(1,98,0,1)
.define C_Timer_4Hz				0x0020		//
EquLine:(1,99,0,1)
.define C_Timer_2Hz				0x0028		//
EquLine:(1,100,0,1)
.define C_Timer_B1				0x0030		//
EquLine:(1,101,0,1)
.define C_Timer_Ext2			0x0038		//
CommentLine:(1,102,0,1)

EquLine:(1,103,0,1)
.define C_PWMO_Off				0x0000		//b6--b9: output pulse
EquLine:(1,104,0,1)
.define C_PWMO_D1				0x0040		//
EquLine:(1,105,0,1)
.define C_PWMO_D2				0x0080		//
EquLine:(1,106,0,1)
.define C_PWMO_D3				0x00C0		//
EquLine:(1,107,0,1)
.define C_PWMO_D4				0x0100		//
EquLine:(1,108,0,1)
.define C_PWMO_D5				0x0140		//
EquLine:(1,109,0,1)
.define C_PWMO_D6				0x0180		//
EquLine:(1,110,0,1)
.define C_PWMO_D7				0x01C0		//
EquLine:(1,111,0,1)
.define C_PWMO_D8				0x0200		//
EquLine:(1,112,0,1)
.define C_PWMO_D9				0x0240		//
EquLine:(1,113,0,1)
.define C_PWMO_D10				0x0280		//
EquLine:(1,114,0,1)
.define C_PWMO_D11				0x02C0		//
EquLine:(1,115,0,1)
.define C_PWMO_D12				0x0300		//
EquLine:(1,116,0,1)
.define C_PWMO_D13				0x0340		//
EquLine:(1,117,0,1)
.define C_PWMO_D14				0x0380		//
EquLine:(1,118,0,1)
.define C_PWMO_Div_2			0x03C0		// 
CommentLine:(1,119,0,1)

CommentLine:(1,120,0,1)
// Define for P_SystemClock
EquLine:(1,121,0,1)
.define C_Fcpu_24M				0x0000		// CPU clock is running at 24MHz
EquLine:(1,122,0,1)
.define C_Fcpu_20M				0x0020		// CPU clock is running at 20MHz
EquLine:(1,123,0,1)
.define C_Fcpu_32M				0x0040		// CPU clock is running at 32MHz
EquLine:(1,124,0,1)
.define C_Fcpu_40M				0x0060		// CPU clock is running at 40MHz
EquLine:(1,125,0,1)
.define C_Fcpu_49M				0x0080		// CPU clock is running at 49MHz
CommentLine:(1,126,0,1)

EquLine:(1,127,0,1)
.define C_FPLL_Div1				0x0000		// b2..b0: frequency select 
EquLine:(1,128,0,1)
.define C_FPLL_Div_2			0x0001		//
EquLine:(1,129,0,1)
.define C_FPLL_Div_4			0x0002		//
EquLine:(1,130,0,1)
.define C_FPLL_Div_8			0x0003		// (default)
EquLine:(1,131,0,1)
.define C_FPLL_Div_16			0x0004		//
EquLine:(1,132,0,1)
.define C_FPLL_Div_32			0x0005		//
EquLine:(1,133,0,1)
.define C_FPLL_Div_64			0x0006		//
EquLine:(1,134,0,1)
.define C_Sleep					0x0007		//
CommentLine:(1,135,0,1)

EquLine:(1,136,0,1)
.define C_32K_Work				0x0010		// b4 = 1: at sleep mode,32.768k still work 
EquLine:(1,137,0,1)
.define C_32K_Off				0x0000		// b4 = 0: at sleep mode,32.768k off 
EquLine:(1,138,0,1)
.define C_32K_StrongMode		0x0008		// b3 = 1: force strong mode
EquLine:(1,139,0,1)
.define C_32K_NormalMode		0x0000		// b3 = 0: auto weak mode(default) 
CommentLine:(1,140,0,1)

EquLine:(1,141,0,1)
.define C_PLL_24M				0x0000		//b5..b7: PLL frequency select
EquLine:(1,142,0,1)
.define C_PLL_20M				0x0020		//
EquLine:(1,143,0,1)
.define C_PLL_32M				0x0040		//
EquLine:(1,144,0,1)
.define C_PLL_40M				0x0060		//
EquLine:(1,145,0,1)
.define C_PLL_49M				0x0080		//
CommentLine:(1,146,0,1)

CommentLine:(1,147,0,1)
// Define for P_ADC_Ctrl
EquLine:(1,148,0,1)
.define C_AD_Enable				0x0001		//b0=1: enable A/D converter
EquLine:(1,149,0,1)
.define C_AD_Disable			0x0000		//b0=0: disable A/D converter
EquLine:(1,150,0,1)
.define C_AD_Line_In			0x0002		//b1=1: microphone disable
EquLine:(1,151,0,1)
.define C_AD_MIC_In				0x0000		//b1=0: microphone enable
EquLine:(1,152,0,1)
.define C_AGC_Enable			0x0004		//b2=1: enable AGC function
EquLine:(1,153,0,1)
.define C_AGC_Disable			0x0000		//b2=0: disable AGC function
EquLine:(1,154,0,1)
.define C_AD_Sample				0x0004		//b3=1: sample the analog signal(manual mode)
EquLine:(1,155,0,1)
.define C_AD_Hold				0x0000		//b3=0: hold(manual mode)
EquLine:(1,156,0,1)
.define C_Auto_Mode				0x0010		//b4=1: A/D auto mode
EquLine:(1,157,0,1)
.define C_Manual_Mode			0x0000		//b4=0: A/D manual mode
EquLine:(1,158,0,1)
.define C_DAC_Current_2mA		0x0040		//b6=1: DAC current = 2mA @ vdd=3V(new option)
EquLine:(1,159,0,1)
.define C_DAC_Current_3mA		0x0000		//b6=0: DAC current = 3mA @ vdd=3V(Default)
EquLine:(1,160,0,1)
.define C_AD_Vref_VDD			0x0080		//b7=1: Vref is VDD
EquLine:(1,161,0,1)
.define C_AD_Vref_VRTPAD		0x0000		//b7=0: Vref is from pin "VRTPAD"
EquLine:(1,162,0,1)
.define C_AD_COMP				0x4000		//b14=1: output voltage of DAC0<Analog input signal
CommentLine:(1,163,0,1)
											//b14=0: output voltage of DAC0>Analog input signal
EquLine:(1,164,0,1)
.define C_AD_RDY				0x8000		//b15=1: A/D digital data ready  0: not ready
CommentLine:(1,165,0,1)

CommentLine:(1,166,0,1)
// Define for P_DAC_Ctrl
EquLine:(1,167,0,1)
.define C_DAC1_Direct			0x0000		// b8 b7: DAC1 latch
EquLine:(1,168,0,1)
.define C_DAC1_LatchA			0x0080		// Latch data to DAC1 by TimerA 
EquLine:(1,169,0,1)
.define C_DAC1_LatchB			0x0100		// Latch data to DAC1 by TimerB
EquLine:(1,170,0,1)
.define C_DAC1_LatchAB			0x0180		// Latch data to DAC1 by TimerA or TimerB
CommentLine:(1,171,0,1)

EquLine:(1,172,0,1)
.define C_DAC2_Direct			0x0000		// b6 b5: DAC2 latch
EquLine:(1,173,0,1)
.define C_DAC2_LatchA			0x0020		// Latch data to DAC2 by TimerA
EquLine:(1,174,0,1)
.define C_DAC2_LatchB			0x0040		// Latch data to DAC2 by TimerB
EquLine:(1,175,0,1)
.define C_DAC2_LatchAB			0x0060		// Latch data to DAC2 by TimerA or TimerB
CommentLine:(1,176,0,1)

EquLine:(1,177,0,1)
.define C_ADC_Direct			0x0000		// b4 b3: ADC latch
EquLine:(1,178,0,1)
.define C_ADC_LatchA			0x0008		// Latch data to ADC by TimerA
EquLine:(1,179,0,1)
.define C_ADC_LatchB			0x0010		// Latch data to ADC by TimerB
EquLine:(1,180,0,1)
.define C_ADC_LatchAB			0x0018		// Latch data to ADC by TimerA or TimerB
CommentLine:(1,181,0,1)

EquLine:(1,182,0,1)
.define C_DAC_Enable			0x0000
EquLine:(1,183,0,1)
.define C_DAC_Disable			0x0002
CommentLine:(1,184,0,1)

CommentLine:(1,185,0,1)
// Define for P_LVD_Ctrl
EquLine:(1,186,0,1)
.define C_LVD24V				0x0000		// LVD = 2.4V  b1b0 
EquLine:(1,187,0,1)
.define C_LVD28V				0x0001		// LVD = 2.8V
EquLine:(1,188,0,1)
.define C_LVD32V				0x0002		// LVD = 3.2V
CommentLine:(1,189,0,1)

EquLine:(1,190,0,1)
.define C_LVD_Result			0x8000		// b15 = 1: below the selected LVD level
CommentLine:(1,191,0,1)

CommentLine:(1,192,0,1)
// GPCE061 flash operation instruction definition
EquLine:(1,193,0,1)
.define C_EnableFlashAccess		0xAAAA
EquLine:(1,194,0,1)
.define C_EraseFlashPage		0x5511
EquLine:(1,195,0,1)
.define C_ProgramFlash			0x5533
CommentLine:(1,196,0,1)

CommentLine:(1,197,0,1)
//P_UART_Command1(W) constant definition
EquLine:(1,198,0,1)
.define C_RX_INT_ENABLE			0x80		// 1:enable, 0:disable
EquLine:(1,199,0,1)
.define C_TX_INT_ENABLE			0x40		// 1:enable, 0:disable
EquLine:(1,200,0,1)
.define C_INTERNAL_RESET		0x20		// 1:reset, 0:non-reset
EquLine:(1,201,0,1)
.define C_PARITY_CHECK			0x08		// 1:even, 0:odd
EquLine:(1,202,0,1)
.define C_PARITY_ENABLE			0x04		// 1:enable, 0:disable
CommentLine:(1,203,0,1)
//P_UART_Command2(W) constant definition
EquLine:(1,204,0,1)
.define C_RX_PIN_ENABLE			0x80
EquLine:(1,205,0,1)
.define C_TX_PIN_ENABLE			0x40
CommentLine:(1,206,0,1)

CommentLine:(1,207,0,1)
// P_TimerA_Data, P_TimerB_Data,
EquLine:(1,208,0,1)
.define C_20MHz					20480000
EquLine:(1,209,0,1)
.define C_24MHz					24576000
EquLine:(1,210,0,1)
.define C_32MHz					32768000
EquLine:(1,211,0,1)
.define C_40MHz					40960000
EquLine:(1,212,0,1)
.define C_49MHz					49152000
CommentLine:(1,213,0,1)

CommentLine:(1,214,0,1)
//.define SystemClock			C_20MHz
CommentLine:(1,215,0,1)
//.define SystemClock			C_24MHz
CommentLine:(1,216,0,1)
//.define SystemClock			C_32MHz
CommentLine:(1,217,0,1)
//.define SystemClock			C_40MHz
EquLine:(1,218,0,1)
.define SystemClock				C_49MHz
CommentLine:(1,219,0,1)

EquLine:(1,220,0,1)
.define TimerClock				SystemClock / 2
CommentLine:(1,221,0,1)

EquLine:(1,222,0,1)
.define C_Timer_Setting_1K    65536 - (TimerClock / 1000)
EquLine:(1,223,0,1)
.define C_Timer_Setting_2K    65536 - (TimerClock / 2000)
EquLine:(1,224,0,1)
.define C_Timer_Setting_3K    65536 - (TimerClock / 3000)
EquLine:(1,225,0,1)
.define C_Timer_Setting_4K    65536 - (TimerClock / 4000)
EquLine:(1,226,0,1)
.define C_Timer_Setting_5K    65536 - (TimerClock / 5000)
EquLine:(1,227,0,1)
.define C_Timer_Setting_6K    65536 - (TimerClock / 6000)
EquLine:(1,228,0,1)
.define C_Timer_Setting_7K    65536 - (TimerClock / 7000)
EquLine:(1,229,0,1)
.define C_Timer_Setting_8K    65536 - (TimerClock / 8000)
EquLine:(1,230,0,1)
.define C_Timer_Setting_9K    65536 - (TimerClock / 9000)
EquLine:(1,231,0,1)
.define C_Timer_Setting_10K    65536 - (TimerClock / 10000)
EquLine:(1,232,0,1)
.define C_Timer_Setting_11K    65536 - (TimerClock / 11000)
EquLine:(1,233,0,1)
.define C_Timer_Setting_12K    65536 - (TimerClock / 12000)
EquLine:(1,234,0,1)
.define C_Timer_Setting_13K    65536 - (TimerClock / 13000)
EquLine:(1,235,0,1)
.define C_Timer_Setting_14K    65536 - (TimerClock / 14000)
EquLine:(1,236,0,1)
.define C_Timer_Setting_15K    65536 - (TimerClock / 15000)
EquLine:(1,237,0,1)
.define C_Timer_Setting_16K    65536 - (TimerClock / 16000)
EquLine:(1,238,0,1)
.define C_Timer_Setting_20K    65536 - (TimerClock / 20000)
EquLine:(1,239,0,1)
.define C_Timer_Setting_24K    65536 - (TimerClock / 24000)
EquLine:(1,240,0,1)
.define C_Timer_Setting_28K    65536 - (TimerClock / 28000)
EquLine:(1,241,0,1)
.define C_Timer_Setting_32K    65536 - (TimerClock / 32000)
EquLine:(1,242,0,1)
.define C_Timer_Setting_36K    65536 - (TimerClock / 36000)
EquLine:(1,243,0,1)
.define C_Timer_Setting_40K    65536 - (TimerClock / 40000)
EquLine:(1,244,0,1)
.define C_Timer_Setting_64K    65536 - (TimerClock / 64000)
CommentLine:(1,245,0,1)

CommentLine:(1,246,0,1)
//for P_Watchdog_Clear
EquLine:(1,247,0,1)
.define C_Watchdog_Clear		0x0001;
CommentLine:(1,248,0,1)
//========================================================================================
CommentLine:(1,249,0,1)
// End of GPCE.inc
CommentLine:(1,250,0,1)
//========================================================================================
ConditionLine:(1,251,0,1)
.endif
EndOfFileLine:(1,251,0,1)

DebugLine(instruction):224,1,0,0,0
DebugLine(path):D:\WorkingFolder\Library_Release\SACMV41b_Beta\GPCE061A_Example_V41b\GPCE061A Example Code\include/
DebugLine(file):D:\WorkingFolder\Library_Release\SACMV41b_Beta\GPCE061A_Example_V41b\GPCE061A Example Code\include\SPI_Flash_CE061.asm
DebugLine(instruction):192,1,0,0,0
CommentLine:(0,13,0,0)

CommentLine:(0,14,0,0)
//**************************************************************************
CommentLine:(0,15,0,0)
// Contant Defintion Area
CommentLine:(0,16,0,0)
//**************************************************************************
CommentLine:(0,17,0,0)
//Using IOB as SPI interface
EquLine:(0,18,0,0)
.define	P_SPI_Data					P_IOB_Data
EquLine:(0,19,0,0)
.define	P_SPI_Buffer				P_IOB_Buffer
EquLine:(0,20,0,0)
.define	P_SPI_Dir					P_IOB_Dir
EquLine:(0,21,0,0)
.define	P_SPI_Attrib				P_IOB_Attrib
CommentLine:(0,22,0,0)
//----------- SPI Hardware Port Definition -------------
CommentLine:(0,23,0,0)
//----------------------------------------------------------------
CommentLine:(0,24,0,0)
//Control I/O:
CommentLine:(0,25,0,0)
//	  IOB12  ---------  CS
CommentLine:(0,26,0,0)
//	  IOB13  ---------  SCK
CommentLine:(0,27,0,0)
//    IOB14  ---------  DI
CommentLine:(0,28,0,0)
//    IOB15  ---------  DO
CommentLine:(0,29,0,0)
//----------------------------------------------------------------
EquLine:(0,30,0,0)
.define B_SPI_DO	0x8000
EquLine:(0,31,0,0)
.define B_SPI_DI	0x4000
EquLine:(0,32,0,0)
.define B_SPI_SCK	0x2000
EquLine:(0,33,0,0)
.define B_SPI_CS	0x1000
CommentLine:(0,34,0,0)

CommentLine:(0,35,0,0)
//----------- Flash Operation Command Definition -------
EquLine:(0,36,0,0)
.define C_SPI_Flash_Read_CMD		0x03
CommentLine:(0,37,0,0)
//.define C_SPI_Flash_Sector_Erase	0xD8
EquLine:(0,38,0,0)
.define C_SPI_Flash_Sector_Erase	0x20
CommentLine:(0,39,0,0)

EquLine:(0,40,0,0)
.define C_SPI_Flash_Chip_Erase		0x60
EquLine:(0,41,0,0)
.define C_SPI_Flash_Page_Program	0x02
EquLine:(0,42,0,0)
.define C_SPI_Flash_Read_Status		0x05
EquLine:(0,43,0,0)
.define C_SPI_Flash_Write_Status	0x01
EquLine:(0,44,0,0)
.define C_SPI_Flash_Write_Enable	0x06
EquLine:(0,45,0,0)
.define C_SPI_Flash_Write_Disable	0x04
EquLine:(0,46,0,0)
.define C_SPI_Flash_Read_ID			0x9F
EquLine:(0,47,0,0)
.define C_SPI_Flash_Fast_Read		0x0B
EquLine:(0,48,0,0)
.define C_SPI_Flash_Power_Down		0xB9
EquLine:(0,49,0,0)
.define C_SPI_Flash_Release_DP		0xAB
EquLine:(0,50,0,0)
.define C_SPI_Flash_Enter_4K		0xA5
EquLine:(0,51,0,0)
.define C_SPI_Flash_Exit_4K			0xB5
EquLine:(0,52,0,0)
.define C_SPI_Flash_Read_ES			0xAB
EquLine:(0,53,0,0)
.define C_SPI_Flash_Read_EMS		0x90
EquLine:(0,54,0,0)
.define C_SPI_Flash_Parallel_Mode	0x55
CommentLine:(0,55,0,0)

CommentLine:(0,56,0,0)
//----------- Flash Status Port Definition ----------
EquLine:(0,57,0,0)
.define C_Flash_Busy				0x01
EquLine:(0,58,0,0)
.define C_Flash_WEL					0x02		// Write Enable Latch
EquLine:(0,59,0,0)
.define C_Flash_BP0					0x04
EquLine:(0,60,0,0)
.define C_Flash_BP1					0x08
EquLine:(0,61,0,0)
.define C_Flash_BP2					0x10
EquLine:(0,62,0,0)
.define C_Flash_BP3					0x20		
EquLine:(0,63,0,0)
.define C_Flash_PEE					0x40		// Program Erase Error
EquLine:(0,64,0,0)
.define C_Flash_SRWP				0x80		// Status Register Write Protect
CommentLine:(0,65,0,0)
//.define C_SPI_BufferSize	128 // be same as that defined in "sacm_DVR4800_user.asm"
CommentLine:(0,66,0,0)

EquLine:(0,67,0,0)
.define C_A3600_BufferLength			64
CommentLine:(0,68,0,0)

CommentLine:(0,69,0,0)
//**************************************************************************
CommentLine:(0,70,0,0)
// Variable Publication Area
CommentLine:(0,71,0,0)
//**************************************************************************
CommentLine:(0,72,0,0)

CommentLine:(0,73,0,0)
//**************************************************************************
CommentLine:(0,74,0,0)
// Function Call Publication Area
CommentLine:(0,75,0,0)
//**************************************************************************
PublicLine:(0,76,0,0)
.public  _SPI_Initial
PublicLine:(0,77,0,0)
.public F_SPI_Initial
PublicLine:(0,78,0,0)
.public  _SPI_ReadAByte
PublicLine:(0,79,0,0)
.public	F_SPI_ReadAByte
PublicLine:(0,80,0,0)
.public  _SPI_ReadAWord
PublicLine:(0,81,0,0)
.public	F_SPI_ReadAWord
PublicLine:(0,82,0,0)
.public  _SPI_ReadNWords
PublicLine:(0,83,0,0)
.public F_SPI_ReadNWords
PublicLine:(0,84,0,0)
.public  _Flash_Write_Enable
PublicLine:(0,85,0,0)
.public F_Flash_Write_Enable
PublicLine:(0,86,0,0)
.public  _Flash_Write_Disable
PublicLine:(0,87,0,0)
.public F_Flash_Write_Disable
PublicLine:(0,88,0,0)
.public  _SPI_Read_Status_Register
PublicLine:(0,89,0,0)
.public F_SPI_Read_Status_Register
PublicLine:(0,90,0,0)
.public  _SPI_Enable_Write_Status_Register
PublicLine:(0,91,0,0)
.public F_SPI_Enable_Write_Status_Register
PublicLine:(0,92,0,0)
.public  _SPI_Write_Status_Register
PublicLine:(0,93,0,0)
.public F_SPI_Write_Status_Register	
PublicLine:(0,94,0,0)
.public  _SPI_Flash_Sector_Erase
PublicLine:(0,95,0,0)
.public F_SPI_Flash_Sector_Erase
PublicLine:(0,96,0,0)
.public  _SPI_Flash_Chip_Erase
PublicLine:(0,97,0,0)
.public F_SPI_Flash_Chip_Erase
PublicLine:(0,98,0,0)
.public  _SPI_Read_Flash_ID
PublicLine:(0,99,0,0)
.public F_SPI_Read_Flash_ID
PublicLine:(0,100,0,0)
.public  _SPI_SendAWord
PublicLine:(0,101,0,0)
.public F_SPI_SendAWord
CommentLine:(0,102,0,0)

PublicLine:(0,103,0,0)
.public F_SPI_ReadNWords_A3600
CommentLine:(0,104,0,0)

CommentLine:(0,105,0,0)
//**************************************************************************
CommentLine:(0,106,0,0)
// External Variable Declaration
CommentLine:(0,107,0,0)
//**************************************************************************
CommentLine:(0,108,0,0)
//.external R_ReadIndex
CommentLine:(0,109,0,0)
//.external R_WriteIndex
ExternalLine:(0,110,0,0)
.external EXT_FLASH_PtrL
ExternalLine:(0,111,0,0)
.external EXT_FLASH_PtrH
CommentLine:(0,112,0,0)
//.external SPI_Buffer
CommentLine:(0,113,0,0)
//.external R_BufferDataCnt
CommentLine:(0,114,0,0)

CommentLine:(0,115,0,0)
//**************************************************************************
CommentLine:(0,116,0,0)
// External Function Declaration
CommentLine:(0,117,0,0)
//**************************************************************************
CommentLine:(0,118,0,0)

CommentLine:(0,119,0,0)
//**************************************************************************
CommentLine:(0,120,0,0)
// External Table Declaration
CommentLine:(0,121,0,0)
//**************************************************************************
CommentLine:(0,122,0,0)

CommentLine:(0,123,0,0)
//**************************************************************************
CommentLine:(0,124,0,0)
// RAM Definition Area
CommentLine:(0,125,0,0)
//**************************************************************************
CommentLine:(0,126,0,0)

CommentLine:(0,127,0,0)
//*****************************************************************************
CommentLine:(0,128,0,0)
// Table Definition Area
CommentLine:(0,129,0,0)
//*****************************************************************************
CommentLine:(0,130,0,0)

CommentLine:(0,131,0,0)

CommentLine:(0,132,0,0)
//**************************************************************************
CommentLine:(0,133,0,0)
// CODE Definition Area
CommentLine:(0,134,0,0)
//**************************************************************************
DebugLine(instruction):224,1,0,0,0
DebugLine(instruction):192,1,0,0,0
SectionLine:(0,135,0,0)
.CODE
CommentLine:(0,136,0,0)
//****************************************************************
CommentLine:(0,137,0,0)
// Function    : F_SPI_Initial
CommentLine:(0,138,0,0)
// Description : Initial SPI interface
CommentLine:(0,139,0,0)
// Destory     : R1
CommentLine:(0,140,0,0)
// Parameter   : None
CommentLine:(0,141,0,0)
// Return      : None
CommentLine:(0,142,0,0)
// Note        : None
CommentLine:(0,143,0,0)
//****************************************************************
ProcDefStartLine:(0,144,0,0)
_SPI_Initial: .proc
InstructionLine:(0,145,0,0)
F_SPI_Initial:
CommentLine:(0,146,0,0)
// set CS as output buffer high (1,1,1)
CommentLine:(0,147,0,0)
// set SCK as output buffer low (1,1,0)
CommentLine:(0,148,0,0)
// set DI as input floating (0,1,1)
CommentLine:(0,149,0,0)
// set DO as output buffer low (1,1,0)
DebugLine(instruction):68,1,0,150,0
InstructionLine:(0,150,0,0)
	R1 = [P_SPI_Dir];
DebugLine(instruction):68,1,2,151,0
InstructionLine:(0,151,0,0)
	R1 |= B_SPI_CS | B_SPI_SCK | B_SPI_DO;
DebugLine(instruction):68,1,4,152,0
InstructionLine:(0,152,0,0)
	R1 &= ~B_SPI_DI;
DebugLine(instruction):68,1,6,153,0
InstructionLine:(0,153,0,0)
	[P_SPI_Dir] = R1;
CommentLine:(0,154,0,0)

DebugLine(instruction):68,1,8,155,0
InstructionLine:(0,155,0,0)
	R1 = [P_SPI_Attrib];
DebugLine(instruction):68,1,10,156,0
InstructionLine:(0,156,0,0)
	R1 |= B_SPI_CS | B_SPI_SCK | B_SPI_DI | B_SPI_DO;
DebugLine(instruction):68,1,12,157,0
InstructionLine:(0,157,0,0)
	[P_SPI_Attrib] = R1;
CommentLine:(0,158,0,0)

DebugLine(instruction):68,1,14,159,0
InstructionLine:(0,159,0,0)
	R1 = [P_SPI_Data];
DebugLine(instruction):68,1,16,160,0
InstructionLine:(0,160,0,0)
	R1 |= B_SPI_CS | B_SPI_DI;
DebugLine(instruction):68,1,18,161,0
InstructionLine:(0,161,0,0)
	R1 &= ~(B_SPI_SCK | B_SPI_DO);
DebugLine(instruction):68,1,20,162,0
InstructionLine:(0,162,0,0)
	[P_SPI_Data] = R1;
CommentLine:(0,163,0,0)
			
DebugLine(instruction):68,1,22,164,0
InstructionLine:(0,164,0,0)
	retf;
ProcDefEndLine:(0,165,0,0)
	.endp
CommentLine:(0,166,0,0)

CommentLine:(0,167,0,0)
//************************************************************************
CommentLine:(0,168,0,0)
// Function:  F_SPI_ReadAByte
CommentLine:(0,169,0,0)
// Description: Read A Byte from SPI Flash
CommentLine:(0,170,0,0)
// Syntax: 
CommentLine:(0,171,0,0)
// Parameter:   R1:Address Low Word, R2:Address High Word
CommentLine:(0,172,0,0)
// Return:      R1
CommentLine:(0,173,0,0)
//************************************************************************
ProcDefStartLine:(0,174,0,0)
_SPI_ReadAByte: .PROC
DebugLine(instruction):68,1,23,175,0
InstructionLine:(0,175,0,0)
	R2 = SP + 3;
DebugLine(instruction):68,1,25,176,0
InstructionLine:(0,176,0,0)
	R1 = [R2++];
DebugLine(instruction):68,1,26,177,0
InstructionLine:(0,177,0,0)
	R2 = [R2];
InstructionLine:(0,178,0,0)
F_SPI_ReadAByte:
CommentLine:(0,179,0,0)
//	R1--input FLASH low,mid address
CommentLine:(0,180,0,0)
//	R2--input FLASH hi address
DebugLine(instruction):68,1,27,181,0
InstructionLine:(0,181,0,0)
	push R1 to [SP];
DebugLine(instruction):68,1,28,182,0
InstructionLine:(0,182,0,0)
	push R2 to [SP];
DebugLine(instruction):68,1,29,183,0
InstructionLine:(0,183,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,31,184,0
InstructionLine:(0,184,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,33,185,0
InstructionLine:(0,185,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,35,186,0
InstructionLine:(0,186,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,37,187,0
InstructionLine:(0,187,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,188,0,0)
	
DebugLine(instruction):68,1,39,189,0
InstructionLine:(0,189,0,0)
	R1 = C_SPI_Flash_Read_CMD;
DebugLine(instruction):68,1,40,190,0
InstructionLine:(0,190,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,42,191,0
InstructionLine:(0,191,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,43,192,0
InstructionLine:(0,192,0,0)
	R1 &= 0xFF;
DebugLine(instruction):68,1,45,193,0
InstructionLine:(0,193,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,47,194,0
InstructionLine:(0,194,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,48,195,0
InstructionLine:(0,195,0,0)
	R4 = R1;
DebugLine(instruction):68,1,49,196,0
InstructionLine:(0,196,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,50,197,0
InstructionLine:(0,197,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,51,198,0
InstructionLine:(0,198,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,53,199,0
InstructionLine:(0,199,0,0)
	R1 = 0xFF;
DebugLine(instruction):68,1,55,200,0
InstructionLine:(0,200,0,0)
	R1 &= R4;
DebugLine(instruction):68,1,56,201,0
InstructionLine:(0,201,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,58,202,0
InstructionLine:(0,202,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,60,203,0
InstructionLine:(0,203,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,62,204,0
InstructionLine:(0,204,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,64,205,0
InstructionLine:(0,205,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,66,206,0
InstructionLine:(0,206,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,68,207,0
InstructionLine:(0,207,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,70,208,0
InstructionLine:(0,208,0,0)
	retf;
ProcDefEndLine:(0,209,0,0)
	.endp;
CommentLine:(0,210,0,0)

CommentLine:(0,211,0,0)
//************************************************************************
CommentLine:(0,212,0,0)
// Function:  F_SPI_Send
CommentLine:(0,213,0,0)
// Description: Send 8-bit data to SPI
CommentLine:(0,214,0,0)
// Syntax: 
CommentLine:(0,215,0,0)
// Parameter:   R1:Low byte data which is sent to SPI
CommentLine:(0,216,0,0)
// Return:      None
CommentLine:(0,217,0,0)
//************************************************************************
InstructionLine:(0,218,0,0)
F_SPI_Send:
DebugLine(instruction):68,1,71,219,0
InstructionLine:(0,219,0,0)
	push R1, R3 to [SP];
DebugLine(instruction):68,1,72,220,0
InstructionLine:(0,220,0,0)
	R2 = 0x80;
InstructionLine:(0,221,0,0)
?L_Send_Data_Loop:
DebugLine(instruction):68,1,74,222,0
InstructionLine:(0,222,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,76,223,0
InstructionLine:(0,223,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,78,224,0
InstructionLine:(0,224,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,80,225,0
InstructionLine:(0,225,0,0)
	test R2, R1;
DebugLine(instruction):68,1,81,226,0
InstructionLine:(0,226,0,0)
	jnz ?L_Send_One;
DebugLine(instruction):68,1,82,227,0
InstructionLine:(0,227,0,0)
	R3 &= ~B_SPI_DO;
DebugLine(instruction):68,1,84,228,0
InstructionLine:(0,228,0,0)
	jmp ?L_Send_Bit_Ready;
InstructionLine:(0,229,0,0)
?L_Send_One:
DebugLine(instruction):68,1,85,230,0
InstructionLine:(0,230,0,0)
	R3 |= B_SPI_DO;
DebugLine(instruction):68,1,87,231,0
InstructionLine:(0,231,0,0)
	nop;
DebugLine(instruction):68,1,88,232,0
InstructionLine:(0,232,0,0)
	nop;
DebugLine(instruction):68,1,89,233,0
InstructionLine:(0,233,0,0)
	nop;
InstructionLine:(0,234,0,0)
?L_Send_Bit_Ready:
DebugLine(instruction):68,1,90,235,0
InstructionLine:(0,235,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,92,236,0
InstructionLine:(0,236,0,0)
	R3 |= B_SPI_SCK;
DebugLine(instruction):68,1,94,237,0
InstructionLine:(0,237,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,96,238,0
InstructionLine:(0,238,0,0)
	R2 = R2 lsr 1;
DebugLine(instruction):68,1,97,239,0
InstructionLine:(0,239,0,0)
	jnz ?L_Send_Data_Loop;
DebugLine(instruction):68,1,98,240,0
InstructionLine:(0,240,0,0)
	pop R1, R3 from [SP];
DebugLine(instruction):68,1,99,241,0
InstructionLine:(0,241,0,0)
	retf;
CommentLine:(0,242,0,0)

CommentLine:(0,243,0,0)
//************************************************************************
CommentLine:(0,244,0,0)
// Function:  F_SPI_Read
CommentLine:(0,245,0,0)
// Description: Read 8-bit data from SPI
CommentLine:(0,246,0,0)
// Syntax: 
CommentLine:(0,247,0,0)
// Parameter:   None
CommentLine:(0,248,0,0)
// Return:      R1:Low byte data which is read from SPI
CommentLine:(0,249,0,0)
//************************************************************************
InstructionLine:(0,250,0,0)
F_SPI_Read:
DebugLine(instruction):68,1,100,251,0
InstructionLine:(0,251,0,0)
	push R2, R3 to [SP];
DebugLine(instruction):68,1,101,252,0
InstructionLine:(0,252,0,0)
	R1 = 0;
DebugLine(instruction):68,1,102,253,0
InstructionLine:(0,253,0,0)
	R2 = 8;
InstructionLine:(0,254,0,0)
?L_Read_Data_Loop:
DebugLine(instruction):68,1,103,255,0
InstructionLine:(0,255,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,105,256,0
InstructionLine:(0,256,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,107,257,0
InstructionLine:(0,257,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,109,258,0
InstructionLine:(0,258,0,0)
	nop;
DebugLine(instruction):68,1,110,259,0
InstructionLine:(0,259,0,0)
	nop;
DebugLine(instruction):68,1,111,260,0
InstructionLine:(0,260,0,0)
	nop;
DebugLine(instruction):68,1,112,261,0
InstructionLine:(0,261,0,0)
	R3 |= B_SPI_SCK;
DebugLine(instruction):68,1,114,262,0
InstructionLine:(0,262,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,116,263,0
InstructionLine:(0,263,0,0)
	R3 = [P_SPI_Data];
DebugLine(instruction):68,1,118,264,0
InstructionLine:(0,264,0,0)
	test R3, B_SPI_DI;
DebugLine(instruction):68,1,120,265,0
InstructionLine:(0,265,0,0)
	jz ?L_CheckBitNumber;
DebugLine(instruction):68,1,121,266,0
InstructionLine:(0,266,0,0)
	R1 |= 0x0001;
InstructionLine:(0,267,0,0)
?L_CheckBitNumber:
DebugLine(instruction):68,1,122,268,0
InstructionLine:(0,268,0,0)
	R2 -= 1;
DebugLine(instruction):68,1,123,269,0
InstructionLine:(0,269,0,0)
	jz ?L_Read_Data_End;
DebugLine(instruction):68,1,124,270,0
InstructionLine:(0,270,0,0)
	R1 = R1 lsl 1;
DebugLine(instruction):68,1,125,271,0
InstructionLine:(0,271,0,0)
	jmp ?L_Read_Data_Loop;
InstructionLine:(0,272,0,0)
?L_Read_Data_End:
DebugLine(instruction):68,1,126,273,0
InstructionLine:(0,273,0,0)
	pop R2, R3 from [SP];
DebugLine(instruction):68,1,127,274,0
InstructionLine:(0,274,0,0)
	retf;
CommentLine:(0,275,0,0)

CommentLine:(0,276,0,0)
//************************************************************************
CommentLine:(0,277,0,0)
// Function:  F_SPI_ReadAWord
CommentLine:(0,278,0,0)
// Description: Read A Word from SPI Flash
CommentLine:(0,279,0,0)
// Syntax: 
CommentLine:(0,280,0,0)
// Parameter:   R1:Address Low Word, R2:Address High Word
CommentLine:(0,281,0,0)
// Return:      R1
CommentLine:(0,282,0,0)
//************************************************************************
ProcDefStartLine:(0,283,0,0)
_SPI_ReadAWord:	.proc
DebugLine(instruction):68,1,128,284,0
InstructionLine:(0,284,0,0)
	R2 = SP + 3;
DebugLine(instruction):68,1,130,285,0
InstructionLine:(0,285,0,0)
	R1 = [R2++];
DebugLine(instruction):68,1,131,286,0
InstructionLine:(0,286,0,0)
	R2 = [R2];
InstructionLine:(0,287,0,0)
F_SPI_ReadAWord:
DebugLine(instruction):68,1,132,288,0
InstructionLine:(0,288,0,0)
	push R2, R4 to [SP];
CommentLine:(0,289,0,0)
//	R1--input FLASH low,mid address
CommentLine:(0,290,0,0)
//	R2--input FLASH hi address
DebugLine(instruction):68,1,133,291,0
InstructionLine:(0,291,0,0)
	push R1 to [SP];
DebugLine(instruction):68,1,134,292,0
InstructionLine:(0,292,0,0)
	push R2 to [SP];
DebugLine(instruction):68,1,135,293,0
InstructionLine:(0,293,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,137,294,0
InstructionLine:(0,294,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,139,295,0
InstructionLine:(0,295,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,141,296,0
InstructionLine:(0,296,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,143,297,0
InstructionLine:(0,297,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,298,0,0)
	
DebugLine(instruction):68,1,145,299,0
InstructionLine:(0,299,0,0)
	R1 = C_SPI_Flash_Read_CMD;
DebugLine(instruction):68,1,146,300,0
InstructionLine:(0,300,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,148,301,0
InstructionLine:(0,301,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,149,302,0
InstructionLine:(0,302,0,0)
	R1 &= 0xFF;
DebugLine(instruction):68,1,151,303,0
InstructionLine:(0,303,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,153,304,0
InstructionLine:(0,304,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,154,305,0
InstructionLine:(0,305,0,0)
	R4 = R1;
DebugLine(instruction):68,1,155,306,0
InstructionLine:(0,306,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,156,307,0
InstructionLine:(0,307,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,157,308,0
InstructionLine:(0,308,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,159,309,0
InstructionLine:(0,309,0,0)
	R1 = 0xFF;
DebugLine(instruction):68,1,161,310,0
InstructionLine:(0,310,0,0)
	R1 &= R4;
DebugLine(instruction):68,1,162,311,0
InstructionLine:(0,311,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,164,312,0
InstructionLine:(0,312,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,166,313,0
InstructionLine:(0,313,0,0)
	R4 = R1;
DebugLine(instruction):68,1,167,314,0
InstructionLine:(0,314,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,169,315,0
InstructionLine:(0,315,0,0)
	R1 = R1 lsl 4;
DebugLine(instruction):68,1,170,316,0
InstructionLine:(0,316,0,0)
	R1 = R1 lsl 4;
DebugLine(instruction):68,1,171,317,0
InstructionLine:(0,317,0,0)
	R1 |= R4;	
DebugLine(instruction):68,1,172,318,0
InstructionLine:(0,318,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,174,319,0
InstructionLine:(0,319,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,176,320,0
InstructionLine:(0,320,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,178,321,0
InstructionLine:(0,321,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,180,322,0
InstructionLine:(0,322,0,0)
	[P_SPI_Data] = R2;
CommentLine:(0,323,0,0)
	
DebugLine(instruction):68,1,182,324,0
InstructionLine:(0,324,0,0)
	pop R2, R4 from [SP];
DebugLine(instruction):68,1,183,325,0
InstructionLine:(0,325,0,0)
	retf;
ProcDefEndLine:(0,326,0,0)
	.endp;
CommentLine:(0,327,0,0)

CommentLine:(0,328,0,0)
//****************************************************************
CommentLine:(0,329,0,0)
// Function    : F_SPI_ReadNWords
CommentLine:(0,330,0,0)
// Description : Get N words from external memory to buffer
CommentLine:(0,331,0,0)
// Destory     : R1, R2, R3, R4
CommentLine:(0,332,0,0)
// Parameter   : R1 : buffer address
CommentLine:(0,333,0,0)
//               R2 : data length
CommentLine:(0,334,0,0)
//               R3 : external memory address low word
CommentLine:(0,335,0,0)
//               R4 : external memory address high word
CommentLine:(0,336,0,0)
// Return      : None
CommentLine:(0,337,0,0)
// Note        : None
CommentLine:(0,338,0,0)
//****************************************************************
ProcDefStartLine:(0,339,0,0)
_SPI_ReadNWords:	.proc
DebugLine(instruction):68,1,184,340,0
InstructionLine:(0,340,0,0)
    R4 = SP + 3;
DebugLine(instruction):68,1,186,341,0
InstructionLine:(0,341,0,0)
    R1 = [R4++];							// buffer address
DebugLine(instruction):68,1,187,342,0
InstructionLine:(0,342,0,0)
    R2 = [R4++];							// data length
DebugLine(instruction):68,1,188,343,0
InstructionLine:(0,343,0,0)
    R3 = [R4++];							// external memory address low byte
DebugLine(instruction):68,1,189,344,0
InstructionLine:(0,344,0,0)
    R4 = [R4];							// external memory address high byte
InstructionLine:(0,345,0,0)
F_SPI_ReadNWords:
DebugLine(instruction):68,1,190,346,0
InstructionLine:(0,346,0,0)
	push R1, R5 to [SP];
DebugLine(instruction):68,1,191,347,0
InstructionLine:(0,347,0,0)
	R5 = [P_SPI_Buffer];		// set CS low
DebugLine(instruction):68,1,193,348,0
InstructionLine:(0,348,0,0)
	R5 &= ~B_SPI_CS;
DebugLine(instruction):68,1,195,349,0
InstructionLine:(0,349,0,0)
	[P_SPI_Data] = R5;
DebugLine(instruction):68,1,197,350,0
InstructionLine:(0,350,0,0)
	R5 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,199,351,0
InstructionLine:(0,351,0,0)
	[P_SPI_Data] = R5;
CommentLine:(0,352,0,0)

CommentLine:(0,353,0,0)
//	push R1 to [SP];			// buffer address
CommentLine:(0,354,0,0)
//	push R2 to [SP];			// data length
DebugLine(instruction):68,1,201,355,0
InstructionLine:(0,355,0,0)
	R5 = R1;
DebugLine(instruction):68,1,202,356,0
InstructionLine:(0,356,0,0)
	R1 = C_SPI_Flash_Read_CMD;
DebugLine(instruction):68,1,203,357,0
InstructionLine:(0,357,0,0)
	call F_SPI_Send;
CommentLine:(0,358,0,0)
//	pop R1 from [SP];
CommentLine:(0,359,0,0)
//	R1 &= 0xFF;
DebugLine(instruction):68,1,205,360,0
InstructionLine:(0,360,0,0)
	R1 = R4;					// address high byte
DebugLine(instruction):68,1,206,361,0
InstructionLine:(0,361,0,0)
	call F_SPI_Send;
CommentLine:(0,362,0,0)
//	pop R1 from [SP];
CommentLine:(0,363,0,0)
//	R4 = R1;
DebugLine(instruction):68,1,208,364,0
InstructionLine:(0,364,0,0)
	R1 = R3;					// address middle byte
DebugLine(instruction):68,1,209,365,0
InstructionLine:(0,365,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,210,366,0
InstructionLine:(0,366,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,211,367,0
InstructionLine:(0,367,0,0)
	call F_SPI_Send;
CommentLine:(0,368,0,0)
//	R1 = 0xFF;
CommentLine:(0,369,0,0)
//	R1 &= R4;
DebugLine(instruction):68,1,213,370,0
InstructionLine:(0,370,0,0)
	R1 = R3;					// address low byte
DebugLine(instruction):68,1,214,371,0
InstructionLine:(0,371,0,0)
	call F_SPI_Send;
InstructionLine:(0,372,0,0)
?L_ReadDataLoop:
DebugLine(instruction):68,1,216,373,0
InstructionLine:(0,373,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,218,374,0
InstructionLine:(0,374,0,0)
	R4 = R1;
DebugLine(instruction):68,1,219,375,0
InstructionLine:(0,375,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,221,376,0
InstructionLine:(0,376,0,0)
	R1 = R1 lsl 4;
DebugLine(instruction):68,1,222,377,0
InstructionLine:(0,377,0,0)
	R1 = R1 lsl 4;
DebugLine(instruction):68,1,223,378,0
InstructionLine:(0,378,0,0)
	R1 |= R4;	
DebugLine(instruction):68,1,224,379,0
InstructionLine:(0,379,0,0)
	[R5++] = R1;
DebugLine(instruction):68,1,225,380,0
InstructionLine:(0,380,0,0)
	R2 -= 1;
DebugLine(instruction):68,1,226,381,0
InstructionLine:(0,381,0,0)
	jnz ?L_ReadDataLoop;
DebugLine(instruction):68,1,227,382,0
InstructionLine:(0,382,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,229,383,0
InstructionLine:(0,383,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,231,384,0
InstructionLine:(0,384,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,233,385,0
InstructionLine:(0,385,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,235,386,0
InstructionLine:(0,386,0,0)
	[P_SPI_Data] = R2;
CommentLine:(0,387,0,0)
	
DebugLine(instruction):68,1,237,388,0
InstructionLine:(0,388,0,0)
	pop R1, R5 from [SP];
DebugLine(instruction):68,1,238,389,0
InstructionLine:(0,389,0,0)
    R3 += R2 lsl 1;
DebugLine(instruction):68,1,239,390,0
InstructionLine:(0,390,0,0)
    R4 += 0, carry;
DebugLine(instruction):68,1,240,391,0
InstructionLine:(0,391,0,0)
	retf;
ProcDefEndLine:(0,392,0,0)
	.endp;
CommentLine:(0,393,0,0)

CommentLine:(0,394,0,0)
//****************************************************************
CommentLine:(0,395,0,0)
// Function    : F_Flash_Write_Enable
CommentLine:(0,396,0,0)
// Description : Enable flash to be written or erased
CommentLine:(0,397,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,398,0,0)
// Parameter   : None
CommentLine:(0,399,0,0)
// Return      : None
CommentLine:(0,400,0,0)
// Note        : None
CommentLine:(0,401,0,0)
//****************************************************************
ProcDefStartLine:(0,402,0,0)
_Flash_Write_Enable:	.proc
InstructionLine:(0,403,0,0)
F_Flash_Write_Enable:
DebugLine(instruction):68,1,241,404,0
InstructionLine:(0,404,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,243,405,0
InstructionLine:(0,405,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,245,406,0
InstructionLine:(0,406,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,247,407,0
InstructionLine:(0,407,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,249,408,0
InstructionLine:(0,408,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,409,0,0)
	
DebugLine(instruction):68,1,251,410,0
InstructionLine:(0,410,0,0)
	R1 = C_SPI_Flash_Write_Enable;
DebugLine(instruction):68,1,252,411,0
InstructionLine:(0,411,0,0)
	call F_SPI_Send;
CommentLine:(0,412,0,0)

DebugLine(instruction):68,1,254,413,0
InstructionLine:(0,413,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,256,414,0
InstructionLine:(0,414,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,258,415,0
InstructionLine:(0,415,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,260,416,0
InstructionLine:(0,416,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,262,417,0
InstructionLine:(0,417,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,264,418,0
InstructionLine:(0,418,0,0)
	retf;
ProcDefEndLine:(0,419,0,0)
	.endp
CommentLine:(0,420,0,0)

CommentLine:(0,421,0,0)
//****************************************************************
CommentLine:(0,422,0,0)
// Function    : F_Flash_Write_Disable
CommentLine:(0,423,0,0)
// Description : Disable flash to be written or erased
CommentLine:(0,424,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,425,0,0)
// Parameter   : None
CommentLine:(0,426,0,0)
// Return      : None
CommentLine:(0,427,0,0)
// Note        : None
CommentLine:(0,428,0,0)
//****************************************************************
ProcDefStartLine:(0,429,0,0)
_Flash_Write_Disable:	.proc
InstructionLine:(0,430,0,0)
F_Flash_Write_Disable:
DebugLine(instruction):68,1,265,431,0
InstructionLine:(0,431,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,267,432,0
InstructionLine:(0,432,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,269,433,0
InstructionLine:(0,433,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,271,434,0
InstructionLine:(0,434,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,273,435,0
InstructionLine:(0,435,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,436,0,0)
	
DebugLine(instruction):68,1,275,437,0
InstructionLine:(0,437,0,0)
	R1 = C_SPI_Flash_Write_Disable;
DebugLine(instruction):68,1,276,438,0
InstructionLine:(0,438,0,0)
	call F_SPI_Send;
CommentLine:(0,439,0,0)

DebugLine(instruction):68,1,278,440,0
InstructionLine:(0,440,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,280,441,0
InstructionLine:(0,441,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,282,442,0
InstructionLine:(0,442,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,284,443,0
InstructionLine:(0,443,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,286,444,0
InstructionLine:(0,444,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,288,445,0
InstructionLine:(0,445,0,0)
	retf;
ProcDefEndLine:(0,446,0,0)
	.endp
CommentLine:(0,447,0,0)

CommentLine:(0,448,0,0)
//****************************************************************
CommentLine:(0,449,0,0)
// Function    : F_SPI_Read_Status_Register
CommentLine:(0,450,0,0)
// Description : Read status register in flash
CommentLine:(0,451,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,452,0,0)
// Parameter   : None
CommentLine:(0,453,0,0)
// Return      : R1 = Value of Status Register
CommentLine:(0,454,0,0)
// Note        : None
CommentLine:(0,455,0,0)
//****************************************************************
ProcDefStartLine:(0,456,0,0)
_SPI_Read_Status_Register:	.proc
InstructionLine:(0,457,0,0)
F_SPI_Read_Status_Register:
DebugLine(instruction):68,1,289,458,0
InstructionLine:(0,458,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,291,459,0
InstructionLine:(0,459,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,293,460,0
InstructionLine:(0,460,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,295,461,0
InstructionLine:(0,461,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,297,462,0
InstructionLine:(0,462,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,463,0,0)
	
DebugLine(instruction):68,1,299,464,0
InstructionLine:(0,464,0,0)
	R1 = C_SPI_Flash_Read_Status;
DebugLine(instruction):68,1,300,465,0
InstructionLine:(0,465,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,302,466,0
InstructionLine:(0,466,0,0)
	call F_SPI_Read;			// Return Status Register
CommentLine:(0,467,0,0)
	
DebugLine(instruction):68,1,304,468,0
InstructionLine:(0,468,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,306,469,0
InstructionLine:(0,469,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,308,470,0
InstructionLine:(0,470,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,310,471,0
InstructionLine:(0,471,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,312,472,0
InstructionLine:(0,472,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,314,473,0
InstructionLine:(0,473,0,0)
	retf;
ProcDefEndLine:(0,474,0,0)
	.endp
CommentLine:(0,475,0,0)

CommentLine:(0,476,0,0)
//****************************************************************
CommentLine:(0,477,0,0)
// Function    : F_SPI_Enable_Write_Status_Register
CommentLine:(0,478,0,0)
// Description : Enable status register in flash to be written
CommentLine:(0,479,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,480,0,0)
// Parameter   : None
CommentLine:(0,481,0,0)
// Return      : None
CommentLine:(0,482,0,0)
// Note        : None
CommentLine:(0,483,0,0)
//****************************************************************
ProcDefStartLine:(0,484,0,0)
_SPI_Enable_Write_Status_Register:	.proc
InstructionLine:(0,485,0,0)
F_SPI_Enable_Write_Status_Register:
DebugLine(instruction):68,1,315,486,0
InstructionLine:(0,486,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,317,487,0
InstructionLine:(0,487,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,319,488,0
InstructionLine:(0,488,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,321,489,0
InstructionLine:(0,489,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,323,490,0
InstructionLine:(0,490,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,491,0,0)
	
DebugLine(instruction):68,1,325,492,0
InstructionLine:(0,492,0,0)
	R1 = C_SPI_Flash_Write_Status;
DebugLine(instruction):68,1,326,493,0
InstructionLine:(0,493,0,0)
	call F_SPI_Send;
CommentLine:(0,494,0,0)

DebugLine(instruction):68,1,328,495,0
InstructionLine:(0,495,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,330,496,0
InstructionLine:(0,496,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,332,497,0
InstructionLine:(0,497,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,334,498,0
InstructionLine:(0,498,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,336,499,0
InstructionLine:(0,499,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,338,500,0
InstructionLine:(0,500,0,0)
	retf;
ProcDefEndLine:(0,501,0,0)
	.endp
CommentLine:(0,502,0,0)
	
CommentLine:(0,503,0,0)
//****************************************************************
CommentLine:(0,504,0,0)
// Function    : F_SPI_Write_Status_Register
CommentLine:(0,505,0,0)
// Description : Write data to status register in flash 
CommentLine:(0,506,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,507,0,0)
// Parameter   : R1 = Data to be written into Status Register
CommentLine:(0,508,0,0)
// Return      : None
CommentLine:(0,509,0,0)
// Note        : None
CommentLine:(0,510,0,0)
//****************************************************************
ProcDefStartLine:(0,511,0,0)
_SPI_Write_Status_Register:	.proc
DebugLine(instruction):68,1,339,512,0
InstructionLine:(0,512,0,0)
	R1 = SP + 3;
DebugLine(instruction):68,1,341,513,0
InstructionLine:(0,513,0,0)
	R1 = [R1];
InstructionLine:(0,514,0,0)
F_SPI_Write_Status_Register:
DebugLine(instruction):68,1,342,515,0
InstructionLine:(0,515,0,0)
	push R1 to [SP];
DebugLine(instruction):68,1,343,516,0
InstructionLine:(0,516,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,345,517,0
InstructionLine:(0,517,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,347,518,0
InstructionLine:(0,518,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,349,519,0
InstructionLine:(0,519,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,351,520,0
InstructionLine:(0,520,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,521,0,0)
	
DebugLine(instruction):68,1,353,522,0
InstructionLine:(0,522,0,0)
	R1 = C_SPI_Flash_Write_Status;
DebugLine(instruction):68,1,354,523,0
InstructionLine:(0,523,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,356,524,0
InstructionLine:(0,524,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,357,525,0
InstructionLine:(0,525,0,0)
	R1 &= 0xFF;
DebugLine(instruction):68,1,359,526,0
InstructionLine:(0,526,0,0)
	call F_SPI_Send;
CommentLine:(0,527,0,0)

DebugLine(instruction):68,1,361,528,0
InstructionLine:(0,528,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,363,529,0
InstructionLine:(0,529,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,365,530,0
InstructionLine:(0,530,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,367,531,0
InstructionLine:(0,531,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,369,532,0
InstructionLine:(0,532,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,371,533,0
InstructionLine:(0,533,0,0)
	retf;
ProcDefEndLine:(0,534,0,0)
	.endp
CommentLine:(0,535,0,0)

CommentLine:(0,536,0,0)
//****************************************************************
CommentLine:(0,537,0,0)
// Function    : F_SPI_Flash_Sector_Erase
CommentLine:(0,538,0,0)
// Description : Erase one sector of flash
CommentLine:(0,539,0,0)
// Destory     : R1, R2, R3, R4
CommentLine:(0,540,0,0)
// Parameter   : R1 = Sector Address Low, R2 = Sector Address High
CommentLine:(0,541,0,0)
// Return      : None
CommentLine:(0,542,0,0)
// Note        : None
CommentLine:(0,543,0,0)
//****************************************************************
ProcDefStartLine:(0,544,0,0)
_SPI_Flash_Sector_Erase:	.proc
DebugLine(instruction):68,1,372,545,0
InstructionLine:(0,545,0,0)
	R2 = SP + 1;
DebugLine(instruction):68,1,374,546,0
InstructionLine:(0,546,0,0)
	R1 = [R2++];
DebugLine(instruction):68,1,375,547,0
InstructionLine:(0,547,0,0)
	R2 = [R2];
InstructionLine:(0,548,0,0)
F_SPI_Flash_Sector_Erase:
DebugLine(instruction):68,1,376,549,0
InstructionLine:(0,549,0,0)
	call F_Flash_Write_Enable;	// Enable sector erase command 
CommentLine:(0,550,0,0)
//	push R1 to [SP];
CommentLine:(0,551,0,0)
//	push R2 to [SP];
DebugLine(instruction):68,1,378,552,0
InstructionLine:(0,552,0,0)
	push R1, R2 to [SP];
DebugLine(instruction):68,1,379,553,0
InstructionLine:(0,553,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,381,554,0
InstructionLine:(0,554,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,383,555,0
InstructionLine:(0,555,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,385,556,0
InstructionLine:(0,556,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,387,557,0
InstructionLine:(0,557,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,558,0,0)
	
DebugLine(instruction):68,1,389,559,0
InstructionLine:(0,559,0,0)
	R1 = C_SPI_Flash_Sector_Erase;
DebugLine(instruction):68,1,390,560,0
InstructionLine:(0,560,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,392,561,0
InstructionLine:(0,561,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,393,562,0
InstructionLine:(0,562,0,0)
	R1 &= 0xFF;
DebugLine(instruction):68,1,395,563,0
InstructionLine:(0,563,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,397,564,0
InstructionLine:(0,564,0,0)
	pop R4 from [SP];
DebugLine(instruction):68,1,398,565,0
InstructionLine:(0,565,0,0)
	R1 = R4 lsr 4;
DebugLine(instruction):68,1,399,566,0
InstructionLine:(0,566,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,400,567,0
InstructionLine:(0,567,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,402,568,0
InstructionLine:(0,568,0,0)
	R1 = R4 & 0xFF;
DebugLine(instruction):68,1,404,569,0
InstructionLine:(0,569,0,0)
	call F_SPI_Send;
CommentLine:(0,570,0,0)

DebugLine(instruction):68,1,406,571,0
InstructionLine:(0,571,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,408,572,0
InstructionLine:(0,572,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,410,573,0
InstructionLine:(0,573,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,412,574,0
InstructionLine:(0,574,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,414,575,0
InstructionLine:(0,575,0,0)
	[P_SPI_Data] = R2;
CommentLine:(0,576,0,0)
	
InstructionLine:(0,577,0,0)
?L_Check_Busy:					// Wait untill sector has been erased successfully (about 1 to 3 seconds)
DebugLine(instruction):68,1,416,578,0
InstructionLine:(0,578,0,0)
	R1 = 0x0001;
DebugLine(instruction):68,1,417,579,0
InstructionLine:(0,579,0,0)
    [P_Watchdog_Clear] = R1;
DebugLine(instruction):68,1,419,580,0
InstructionLine:(0,580,0,0)
	call F_SPI_Read_Status_Register;
DebugLine(instruction):68,1,421,581,0
InstructionLine:(0,581,0,0)
	test R1, C_Flash_Busy;
DebugLine(instruction):68,1,422,582,0
InstructionLine:(0,582,0,0)
	jnz ?L_Check_Busy;
CommentLine:(0,583,0,0)

DebugLine(instruction):68,1,423,584,0
InstructionLine:(0,584,0,0)
	retf;	
ProcDefEndLine:(0,585,0,0)
	.endp
CommentLine:(0,586,0,0)

CommentLine:(0,587,0,0)
//****************************************************************
CommentLine:(0,588,0,0)
// Function    : F_SPI_Flash_Chip_Erase
CommentLine:(0,589,0,0)
// Description :  Erase hole chip of flash 
CommentLine:(0,590,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,591,0,0)
// Parameter   : None
CommentLine:(0,592,0,0)
// Return      : None
CommentLine:(0,593,0,0)
// Note        : None
CommentLine:(0,594,0,0)
//****************************************************************
ProcDefStartLine:(0,595,0,0)
_SPI_Flash_Chip_Erase:	.proc
InstructionLine:(0,596,0,0)
F_SPI_Flash_Chip_Erase:
DebugLine(instruction):68,1,424,597,0
InstructionLine:(0,597,0,0)
	call F_Flash_Write_Enable;		// Enable chip erase command 
DebugLine(instruction):68,1,426,598,0
InstructionLine:(0,598,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,428,599,0
InstructionLine:(0,599,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,430,600,0
InstructionLine:(0,600,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,432,601,0
InstructionLine:(0,601,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,434,602,0
InstructionLine:(0,602,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,603,0,0)
	
DebugLine(instruction):68,1,436,604,0
InstructionLine:(0,604,0,0)
	R1 = C_SPI_Flash_Chip_Erase;
DebugLine(instruction):68,1,438,605,0
InstructionLine:(0,605,0,0)
	call F_SPI_Send;
CommentLine:(0,606,0,0)

DebugLine(instruction):68,1,440,607,0
InstructionLine:(0,607,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,442,608,0
InstructionLine:(0,608,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,444,609,0
InstructionLine:(0,609,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,446,610,0
InstructionLine:(0,610,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,448,611,0
InstructionLine:(0,611,0,0)
	[P_SPI_Data] = R2;
CommentLine:(0,612,0,0)
	
InstructionLine:(0,613,0,0)
?L_Check_Busy:						// Wait untill chip has been erased successfully (about 128 to 256 seconds)
DebugLine(instruction):68,1,450,614,0
InstructionLine:(0,614,0,0)
	R1 = 0x0001;
DebugLine(instruction):68,1,451,615,0
InstructionLine:(0,615,0,0)
    [P_Watchdog_Clear] = R1;
DebugLine(instruction):68,1,453,616,0
InstructionLine:(0,616,0,0)
	call F_SPI_Read_Status_Register;
DebugLine(instruction):68,1,455,617,0
InstructionLine:(0,617,0,0)
	test R1, C_Flash_Busy;
DebugLine(instruction):68,1,456,618,0
InstructionLine:(0,618,0,0)
	jnz ?L_Check_Busy;	
DebugLine(instruction):68,1,457,619,0
InstructionLine:(0,619,0,0)
	retf;
ProcDefEndLine:(0,620,0,0)
	.endp
CommentLine:(0,621,0,0)

CommentLine:(0,622,0,0)
//****************************************************************
CommentLine:(0,623,0,0)
// Function    : F_SPI_Read_Flash_ID
CommentLine:(0,624,0,0)
// Description : Read flash manufacturer,memory and individual device ID 
CommentLine:(0,625,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,626,0,0)
// Parameter   : None
CommentLine:(0,627,0,0)
// Return      : R1 = Manufacturer and memory ID, R2 = Individual Device ID
CommentLine:(0,628,0,0)
// Note        : None
CommentLine:(0,629,0,0)
//****************************************************************
ProcDefStartLine:(0,630,0,0)
_SPI_Read_Flash_ID:	.proc
InstructionLine:(0,631,0,0)
F_SPI_Read_Flash_ID:
DebugLine(instruction):68,1,458,632,0
InstructionLine:(0,632,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,460,633,0
InstructionLine:(0,633,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,462,634,0
InstructionLine:(0,634,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,464,635,0
InstructionLine:(0,635,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,466,636,0
InstructionLine:(0,636,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,637,0,0)
	
DebugLine(instruction):68,1,468,638,0
InstructionLine:(0,638,0,0)
	R1 = C_SPI_Flash_Read_ID;
DebugLine(instruction):68,1,470,639,0
InstructionLine:(0,639,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,472,640,0
InstructionLine:(0,640,0,0)
	call F_SPI_Read;			// Read Manufacturer ID
DebugLine(instruction):68,1,474,641,0
InstructionLine:(0,641,0,0)
	push R1 to [SP];
DebugLine(instruction):68,1,475,642,0
InstructionLine:(0,642,0,0)
	call F_SPI_Read;			// Read Memory ID
DebugLine(instruction):68,1,477,643,0
InstructionLine:(0,643,0,0)
	push R1 to [SP];
DebugLine(instruction):68,1,478,644,0
InstructionLine:(0,644,0,0)
	call F_SPI_Read;			// Read Individual Device ID
DebugLine(instruction):68,1,480,645,0
InstructionLine:(0,645,0,0)
	R2 = R1;					// Return Individual Device ID
DebugLine(instruction):68,1,481,646,0
InstructionLine:(0,646,0,0)
	pop R3 from [SP];
DebugLine(instruction):68,1,482,647,0
InstructionLine:(0,647,0,0)
	pop R1 from [SP];
DebugLine(instruction):68,1,483,648,0
InstructionLine:(0,648,0,0)
	R3 = R3 LSL 4;
DebugLine(instruction):68,1,484,649,0
InstructionLine:(0,649,0,0)
	R3 = R3 LSL 4;
DebugLine(instruction):68,1,485,650,0
InstructionLine:(0,650,0,0)
	R1 |= R3;					// Return Memory ID and Manufacturer ID
CommentLine:(0,651,0,0)

DebugLine(instruction):68,1,486,652,0
InstructionLine:(0,652,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,488,653,0
InstructionLine:(0,653,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,490,654,0
InstructionLine:(0,654,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,492,655,0
InstructionLine:(0,655,0,0)
	R3 |= B_SPI_CS;
DebugLine(instruction):68,1,494,656,0
InstructionLine:(0,656,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,496,657,0
InstructionLine:(0,657,0,0)
	retf;
ProcDefEndLine:(0,658,0,0)
	.endp
CommentLine:(0,659,0,0)

CommentLine:(0,660,0,0)
//****************************************************************
CommentLine:(0,661,0,0)
// Function    : F_SPI_SendAWord
CommentLine:(0,662,0,0)
// Description : Write a word data to flash
CommentLine:(0,663,0,0)
// Destory     : R1, R2, R3
CommentLine:(0,664,0,0)
// Parameter   : R1 = Address Low, R2 = Address High, R3 = one word of data
CommentLine:(0,665,0,0)
// Return      : None
CommentLine:(0,666,0,0)
// Note        : None
CommentLine:(0,667,0,0)
//****************************************************************
ProcDefStartLine:(0,668,0,0)
_SPI_SendAWord:	.proc
DebugLine(instruction):68,1,497,669,0
InstructionLine:(0,669,0,0)
	R3 = SP + 3;
DebugLine(instruction):68,1,499,670,0
InstructionLine:(0,670,0,0)
	R1 = [R3++];
DebugLine(instruction):68,1,500,671,0
InstructionLine:(0,671,0,0)
	R2 = [R3++];
DebugLine(instruction):68,1,501,672,0
InstructionLine:(0,672,0,0)
	R3 = [R3];
InstructionLine:(0,673,0,0)
F_SPI_SendAWord:
DebugLine(instruction):68,1,502,674,0
InstructionLine:(0,674,0,0)
	push R3 to [SP];
DebugLine(instruction):68,1,503,675,0
InstructionLine:(0,675,0,0)
	push R1 to [SP];
DebugLine(instruction):68,1,504,676,0
InstructionLine:(0,676,0,0)
	push R2 to [SP];
DebugLine(instruction):68,1,505,677,0
InstructionLine:(0,677,0,0)
	R3 = [P_SPI_Buffer];
DebugLine(instruction):68,1,507,678,0
InstructionLine:(0,678,0,0)
	R3 &= ~B_SPI_CS;
DebugLine(instruction):68,1,509,679,0
InstructionLine:(0,679,0,0)
	[P_SPI_Data] = R3;
DebugLine(instruction):68,1,511,680,0
InstructionLine:(0,680,0,0)
	R3 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,513,681,0
InstructionLine:(0,681,0,0)
	[P_SPI_Data] = R3;
CommentLine:(0,682,0,0)
	
DebugLine(instruction):68,1,515,683,0
InstructionLine:(0,683,0,0)
	R1 = C_SPI_Flash_Page_Program;
DebugLine(instruction):68,1,516,684,0
InstructionLine:(0,684,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,518,685,0
InstructionLine:(0,685,0,0)
	pop R1 from [SP];		// Address High
DebugLine(instruction):68,1,519,686,0
InstructionLine:(0,686,0,0)
	R1 &= 0xFF;
DebugLine(instruction):68,1,521,687,0
InstructionLine:(0,687,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,523,688,0
InstructionLine:(0,688,0,0)
	pop R4 from [SP];		// Address Middle and Low
DebugLine(instruction):68,1,524,689,0
InstructionLine:(0,689,0,0)
	R1 = R4 lsr 4;
DebugLine(instruction):68,1,525,690,0
InstructionLine:(0,690,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,526,691,0
InstructionLine:(0,691,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,528,692,0
InstructionLine:(0,692,0,0)
	R1 = R4 & 0xFF;
DebugLine(instruction):68,1,530,693,0
InstructionLine:(0,693,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,532,694,0
InstructionLine:(0,694,0,0)
	pop R4 from [SP];		// Data High and Low
DebugLine(instruction):68,1,533,695,0
InstructionLine:(0,695,0,0)
	R1 = R4 & 0xFF;
DebugLine(instruction):68,1,535,696,0
InstructionLine:(0,696,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,537,697,0
InstructionLine:(0,697,0,0)
	R1 = R4 lsr 4;
DebugLine(instruction):68,1,538,698,0
InstructionLine:(0,698,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,539,699,0
InstructionLine:(0,699,0,0)
	call F_SPI_Send; 
CommentLine:(0,700,0,0)

DebugLine(instruction):68,1,541,701,0
InstructionLine:(0,701,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,543,702,0
InstructionLine:(0,702,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,545,703,0
InstructionLine:(0,703,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,547,704,0
InstructionLine:(0,704,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,549,705,0
InstructionLine:(0,705,0,0)
	[P_SPI_Data] = R2;
CommentLine:(0,706,0,0)

InstructionLine:(0,707,0,0)
?L_Check_Busy:						// Wait untill one word data has been written into flash successfully (about 3 to 12ms).
DebugLine(instruction):68,1,551,708,0
InstructionLine:(0,708,0,0)
	call F_SPI_Read_Status_Register; // WatchDog overflow can escape from dead loop
DebugLine(instruction):68,1,553,709,0
InstructionLine:(0,709,0,0)
	test R1, C_Flash_Busy;
DebugLine(instruction):68,1,554,710,0
InstructionLine:(0,710,0,0)
	jnz ?L_Check_Busy;	
CommentLine:(0,711,0,0)

DebugLine(instruction):68,1,555,712,0
InstructionLine:(0,712,0,0)
	retf;
ProcDefEndLine:(0,713,0,0)
	.endp
CommentLine:(0,714,0,0)

CommentLine:(0,715,0,0)
//****************************************************************
CommentLine:(0,716,0,0)
// Function    : F_SPI_ReadNWords_A3600
CommentLine:(0,717,0,0)
// Description : Get N words from external memory to buffer
CommentLine:(0,718,0,0)
// Destory     : R1, R2, R3, R4
CommentLine:(0,719,0,0)
// Parameter   : R1 : buffer address
CommentLine:(0,720,0,0)
//               R2 : data length
CommentLine:(0,721,0,0)
//               R3 : external memory address low word
CommentLine:(0,722,0,0)
//               R4 : external memory address high word
CommentLine:(0,723,0,0)
// Return      : None
CommentLine:(0,724,0,0)
// Note        : None
CommentLine:(0,725,0,0)
//****************************************************************
CommentLine:(0,726,0,0)
//_SPI_ReadNWords_A3600:	.proc
CommentLine:(0,727,0,0)
//    R4 = SP + 3;
CommentLine:(0,728,0,0)
//    R1 = [R4++];							// buffer address
CommentLine:(0,729,0,0)
//    R2 = [R4++];							// data length
CommentLine:(0,730,0,0)
//    R3 = [R4++];							// external memory address low byte
CommentLine:(0,731,0,0)
//    R4 = [R4];							// external memory address high byte
ProcDefStartLine:(0,732,0,0)
F_SPI_ReadNWords_A3600:	.proc
DebugLine(instruction):68,1,556,733,0
InstructionLine:(0,733,0,0)
	push R1, R5 to [SP];
DebugLine(instruction):68,1,557,734,0
InstructionLine:(0,734,0,0)
	push R5 to [SP];
DebugLine(instruction):68,1,558,735,0
InstructionLine:(0,735,0,0)
	R5 = [P_SPI_Buffer];		// set CS low
DebugLine(instruction):68,1,560,736,0
InstructionLine:(0,736,0,0)
	R5 &= ~B_SPI_CS;
DebugLine(instruction):68,1,562,737,0
InstructionLine:(0,737,0,0)
	[P_SPI_Data] = R5;
DebugLine(instruction):68,1,564,738,0
InstructionLine:(0,738,0,0)
	R5 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,566,739,0
InstructionLine:(0,739,0,0)
	[P_SPI_Data] = R5;
CommentLine:(0,740,0,0)

DebugLine(instruction):68,1,568,741,0
InstructionLine:(0,741,0,0)
	R5 = R1;
DebugLine(instruction):68,1,569,742,0
InstructionLine:(0,742,0,0)
	R1 = C_SPI_Flash_Read_CMD;
DebugLine(instruction):68,1,570,743,0
InstructionLine:(0,743,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,572,744,0
InstructionLine:(0,744,0,0)
	R1 = R4;					// address high byte
DebugLine(instruction):68,1,573,745,0
InstructionLine:(0,745,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,575,746,0
InstructionLine:(0,746,0,0)
	R1 = R3;					// address middle byte
DebugLine(instruction):68,1,576,747,0
InstructionLine:(0,747,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,577,748,0
InstructionLine:(0,748,0,0)
	R1 = R1 lsr 4;
DebugLine(instruction):68,1,578,749,0
InstructionLine:(0,749,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,580,750,0
InstructionLine:(0,750,0,0)
	R1 = R3;					// address low byte
DebugLine(instruction):68,1,581,751,0
InstructionLine:(0,751,0,0)
	call F_SPI_Send;
DebugLine(instruction):68,1,583,752,0
InstructionLine:(0,752,0,0)
	R3 = R5;
DebugLine(instruction):68,1,584,753,0
InstructionLine:(0,753,0,0)
	pop R5 from [SP];
InstructionLine:(0,754,0,0)
?L_ReadDataLoop:
DebugLine(instruction):68,1,585,755,0
InstructionLine:(0,755,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,587,756,0
InstructionLine:(0,756,0,0)
	R4 = R1;
DebugLine(instruction):68,1,588,757,0
InstructionLine:(0,757,0,0)
	call F_SPI_Read;
DebugLine(instruction):68,1,590,758,0
InstructionLine:(0,758,0,0)
	R1 = R1 lsl 4;
DebugLine(instruction):68,1,591,759,0
InstructionLine:(0,759,0,0)
	R1 = R1 lsl 4;
DebugLine(instruction):68,1,592,760,0
InstructionLine:(0,760,0,0)
	R1 |= R4;
DebugLine(instruction):68,1,593,761,0
InstructionLine:(0,761,0,0)
	push R3 to [SP];
DebugLine(instruction):68,1,594,762,0
InstructionLine:(0,762,0,0)
	R3 += R5;
DebugLine(instruction):68,1,595,763,0
InstructionLine:(0,763,0,0)
	[R3] = R1;
DebugLine(instruction):68,1,596,764,0
InstructionLine:(0,764,0,0)
	pop R3 from [SP];
DebugLine(instruction):68,1,597,765,0
InstructionLine:(0,765,0,0)
	R5 += 1;
DebugLine(instruction):68,1,598,766,0
InstructionLine:(0,766,0,0)
	R5 &= C_A3600_BufferLength - 1;
DebugLine(instruction):68,1,599,767,0
InstructionLine:(0,767,0,0)
	R2 -= 1;
DebugLine(instruction):68,1,600,768,0
InstructionLine:(0,768,0,0)
	jnz ?L_ReadDataLoop;
DebugLine(instruction):68,1,601,769,0
InstructionLine:(0,769,0,0)
	R2 = [P_SPI_Buffer];
DebugLine(instruction):68,1,603,770,0
InstructionLine:(0,770,0,0)
	R2 &= ~B_SPI_SCK;
DebugLine(instruction):68,1,605,771,0
InstructionLine:(0,771,0,0)
	[P_SPI_Data] = R2;
DebugLine(instruction):68,1,607,772,0
InstructionLine:(0,772,0,0)
	R2 |= B_SPI_CS;
DebugLine(instruction):68,1,609,773,0
InstructionLine:(0,773,0,0)
	[P_SPI_Data] = R2;
CommentLine:(0,774,0,0)
	
DebugLine(instruction):68,1,611,775,0
InstructionLine:(0,775,0,0)
	pop R1, R5 from [SP];
DebugLine(instruction):68,1,612,776,0
InstructionLine:(0,776,0,0)
	retf;
ProcDefEndLine:(0,777,0,0)
	.endp;
EndOfFileLine:(0,777,0,0)

